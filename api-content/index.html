{"posts":[{"title":"uniapp-template ","content":"一个基于 Vue 3 + TypeScript + Pinia 的 UniApp 跨平台开发模板项目，集成了完整的开发工具链和组件库。 项目特性 🚀 Vue 3 - 使用最新的 Vue 3 Composition API 📱 跨平台 - 支持微信小程序、H5、App 等多个平台 🔧 TypeScript - 完整的 TypeScript 支持 📦 Pinia - 现代化的状态管理 🎨 Sass/SCSS - CSS 预处理器支持 📡 API 管理 - 集成 Swagger API 模板生成 🔍 ESLint + Prettier - 代码质量检查和格式化 📁 Monorepo - 使用 pnpm workspace 管理多包项目 🎯 Wot Design Uni - 集成完整的UI组件库 🛠️ 开发工具 - 自动路由生成、页面监听等插件 🔐 权限管理 - 完整的登录授权和token管理 📤 文件上传 - 集成阿里云OSS文件上传功能 📊 状态管理 - 丰富的Vue 3 Hooks和状态管理工具 项目结构 uniapp-template/ ├── components/ # 公共组件和工具 │ ├── eslint-config/ # ESLint 配置包 │ └── swagger-api-templates/ # API 模板生成工具 ├── packages/ │ └── uni-template/ # 主要的 UniApp 项目 │ ├── src/ │ │ ├── pages/ # 页面文件 │ │ │ ├── common/ # 公共页面 │ │ │ ├── tabbar/ # 底部导航页面 │ │ │ └── template/ # 模板页面 │ │ ├── components/ # 组件 │ │ │ ├── common/ # 公共组件 │ │ │ ├── help/ # 帮助组件 │ │ │ └── request/ # 请求相关组件 │ │ ├── layout/ # 布局组件 │ │ │ ├── navigation/ # 导航栏组件 │ │ │ └── pageContainer/# 页面容器组件 │ │ ├── store/ # Pinia 状态管理 │ │ ├── request/ # API 请求封装 │ │ ├── utils/ # 工具函数 │ │ ├── hooks/ # Vue 3 Hooks │ │ ├── enums/ # 枚举定义 │ │ ├── types/ # 类型定义 │ │ ├── static/ # 静态资源 │ │ └── uni_modules/ # UniApp 模块 │ │ └── wot-design-uni/ # Wot Design Uni 组件库 │ ├── plugins/ # 自定义插件 │ ├── scripts/ # 构建脚本 │ └── dist/ # 构建输出 ├── package.json # 根包配置 ├── pnpm-workspace.yaml # pnpm 工作区配置 └── README.md # 项目说明文档 快速开始 环境要求 Node.js &gt;= 18 pnpm &gt;= 8 安装依赖 pnpm install 开发命令 # 进入项目目录 cd packages/uni-template # 微信小程序开发 pnpm dev # H5 开发 pnpm dev:h5 # App 开发 pnpm dev:app # 其他平台 pnpm dev:mp-alipay # 支付宝小程序 pnpm dev:mp-baidu # 百度小程序 pnpm dev:mp-qq # QQ 小程序 pnpm dev:mp-toutiao # 字节跳动小程序 pnpm dev:mp-kuaishou # 快手小程序 pnpm dev:mp-jd # 京东小程序 pnpm dev:mp-lark # 飞书小程序 构建命令 # 进入项目目录 cd packages/uni-template # 微信小程序构建 pnpm build # H5 构建 pnpm build:h5 # App 构建 pnpm build:app API 生成 # 进入项目目录 cd packages/uni-template # 根据apifox/swagger 文档导出接口json地址，修改项目配置文件：swaggerApi.config.js projects: [{ name: '', url: 'http://127.0.0.1:4523/export/openapi/2?version=3.0' }] # 根据 apifox 文档生成 API 接口 pnpm api 核心组件 布局组件 Navigation - 自定义导航栏组件，支持状态栏高度适配 PageContainer - 页面容器组件，统一页面布局 公共组件 ImageUpload - 图片上传组件，支持多图上传、预览、删除 Poster - 海报生成组件，支持Canvas绘制和图片合成 PullToRefresh - 下拉刷新组件，支持自定义刷新逻辑 RefreshList - 列表刷新组件，集成下拉刷新和上拉加载 RichText - 富文本组件，支持HTML内容渲染 Ellipsis - 文本省略组件，支持多行文本截断 UI 组件库 项目集成了 Wot Design Uni 组件库，包含： 基础组件：Button、Cell、Icon、Input、Gap、Divider等 表单组件：Form、Checkbox、Radio、Switch、InputNumber等 反馈组件：Toast、Dialog、Loading、Notify、MessageBox等 展示组件：Card、Tag、Badge、Progress、Circle等 导航组件：Tabs、Tabbar、Navbar、Sidebar、IndexBar等 数据录入：DatetimePicker、Calendar、ColPicker、PasswordInput等 样式文件组织 src/ ├── assets/ │ └── index.scss # 全局样式入口 ├── components/ │ └── */index.scss # 组件样式文件 ├── pages/ │ └── */index.scss # 页面样式文件 └── layout/ └── */index.scss # 布局样式文件 主题变量 使用 CSS 变量定义主题色彩和尺寸： :root { --wot-color-theme: #517cf0; --wot-color-success: #34d19d; --wot-color-warning: #f0883a; --wot-color-danger: #fa4350; } 开发工具 插件工具 项目包含两个自定义插件，用于自动化开发流程： 路由生成插件 (getRoute.mjs) # 进入项目目录 cd packages/uni-template # 手动生成路由文件 pnpm route 功能说明： 自动读取 src/pages.json 配置 生成 src/routes.ts 路由映射文件 生成 src/RouteParams.d.ts 路由参数类型定义 支持主包页面和分包页面 自动提取页面标题和路径信息 生成 tabbar 页面配置 生成的文件： routes.ts - 包含 routeNames 对象和类型定义 RouteParams.d.ts - 路由参数的 TypeScript 类型定义 页面监听插件 (watch-pages.mjs) # 开发模式下自动运行（包含在 dev 命令中） pnpm dev 功能说明： 监听 src/pages.json 文件变化 文件变更时自动重新生成路由文件 开发模式下提供实时路由更新 避免手动维护路由映射的繁琐工作 工作流程： 启动时执行一次路由生成 持续监听 pages.json 文件 检测到变更时自动重新生成路由文件 控制台输出生成状态和结果 状态管理 Pinia Store 使用 Pinia 进行状态管理，store 文件放在 src/store/ 目录下： // src/store/common/useGlobalStore.ts export const useGlobalStore = defineStore('globalStore', () =&gt; { const userInfo = ref&lt;MemberDto&gt;() const getUserInfo = async () =&gt; { const { data, code } = await api.get['/api/member/v1/member/getUserInfo']() data &amp;&amp; setUserInfo(data) return { data, code } } return { userInfo, getUserInfo } }) 主要Store： useGlobalStore - 全局状态管理，用户信息、登录状态等 useSystemInfo - 系统信息管理，设备信息、屏幕尺寸等 useGetAccountInfo - 小程序环境信息管理 组合式函数 (Hooks) 项目提供了多个实用的组合式函数： 状态管理类 useBoolean - 布尔值状态管理，支持setTrue/setFalse/toggle等操作 useToggle - 切换状态管理，支持两个值之间的切换 useState - 受控/非受控状态管理，类似React的useState useUpdate - 强制更新组件 表单和数据处理 useFormService - 表单服务封装，支持表单数据管理和重置 useMutate - 数据获取和状态管理，支持数据格式化 usePullToRefresh - 下拉刷新和上拉加载更多 useModify - 页面数据修改和更新 页面和导航 useNavigation - 页面导航管理，支持各种跳转方式 useParams - 页面参数获取，支持场景值解析 useGetParams - 组件中获取页面参数 useScroll - 滚动监听和吸顶效果 工具类 useLockFn - 函数防抖和锁定，防止重复调用 useNetworkStatus - 网络状态监听 useUpdateEffect - 忽略首次执行的effect API 请求 项目使用自定义封装的请求库，支持根据swagger文档生成ts、自动token管理和静默授权，以及统一的错误处理和响应拦截。 请求封装 使用自定义封装的请求库，配置文件在 src/request/ 目录下： // 使用请求 const data = await api.get['/api/member/v1/activity/activity']() const result = await api.post['/api/auth/login']({ username, password }) 特性： 根据swagger文档生成ts 自动token管理和静默授权 统一的错误处理和响应拦截 支持请求和响应拦截器 自动处理FormData和查询参数 请求实例 // src/request/instance.ts const instance = Request.create({ baseUrl: apiUrl }) // 请求拦截器 - 自动添加token instance.requestInterceptors.use(async (config) =&gt; { let token = getAuthorization() if (!token &amp;&amp; silentAuthorization) { const { data } = await getToken(silentAuthorizationUrl) token = data setAuthorization(token) } config.headers = { ...config.headers, Authorization: token } return config }) // 响应拦截器 - 统一错误处理 instance.responseInterceptors.use((res) =&gt; { if ([403, 40003, 401].indexOf(res.data.code) !== -1) { // token过期处理 removeAuthorization() loginUrl &amp;&amp; uni.navigateTo({ url: loginUrl }) throw new Error() } return res.data }) 工具函数 文件处理 阿里云OSS上传 - 支持图片、文件上传到阿里云OSS 图片处理 - 图片压缩、裁剪、格式转换等 文件类型检测 - 自动识别图片、视频、音频、PDF等文件类型 数据处理 高精度计算 - 解决JavaScript浮点数精度问题 数据格式化 - 金额格式化、电话号码脱敏等 数组操作 - 去重、排序、转换等工具函数 平台适配 设备信息 - 获取设备型号、屏幕尺寸、状态栏高度等 平台检测 - 自动识别当前运行平台 网络状态 - 监听网络状态变化 支持平台 ✅ 微信小程序 (MP-WEIXIN) ✅ H5 (H5) ✅ App (Android/iOS) ✅ 支付宝小程序 (MP-ALIPAY) ✅ 百度小程序 (MP-BAIDU) ✅ QQ 小程序 (MP-QQ) ✅ 字节跳动小程序 (MP-TOUTIAO) ✅ 快手小程序 (MP-KUAISHOU) ✅ 京东小程序 (MP-JD) ✅ 飞书小程序 (MP-LARK) ✅ 快应用 (QUICKAPP-WEBVIEW) 技术栈 框架: UniApp 3.x + Vue 3.5.11 前端: Vue 3 + TypeScript 5.9.2 状态管理: Pinia 2.3.1 样式: Sass 1.66.1 构建工具: Vite 5.2.11 代码规范: ESLint 8.57.1 + Prettier 3.6.2 包管理: pnpm workspace API 工具: 自定义请求封装 + Swagger 模板生成 UI 组件: Wot Design Uni 开发工具: 自动路由生成、页面监听等插件 工具库: dayjs 1.11.13 (日期处理) 开发指南 页面路由 页面路由配置在 src/pages.json 中，支持自动路由生成。 组件开发 公共组件放在 src/components/ 目录下，支持 TypeScript 类型定义： &lt;template&gt; &lt;view class=&quot;custom-component&quot;&gt; &lt;slot /&gt; &lt;/view&gt; &lt;/template&gt; &lt;script setup lang=&quot;ts&quot;&gt; interface Props { title?: string } defineProps&lt;Props&gt;() &lt;/script&gt; 类型定义 项目包含完整的 TypeScript 类型定义： src/types/ - 全局类型定义 src/enums/ - 枚举定义 src/request/types/ - 请求相关类型 src/components/request/types/ - 请求组件类型 配置说明 环境配置 src/config.ts - 应用配置，API地址、登录配置等 src/manifest.json - 应用清单文件 vite.config.ts - Vite 构建配置 tsconfig.json - TypeScript 配置 API 配置 swaggerApi.config.js - Swagger API 生成配置 ESLint 配置 components/eslint-config/ - 统一的 ESLint 配置 部署说明 小程序部署 构建项目：pnpm build 使用微信开发者工具打开 dist/build/mp-weixin 目录 上传代码到微信小程序后台 H5 部署 构建项目：pnpm build:h5 将 dist/build/h5 目录部署到 Web 服务器 App 部署 构建项目：pnpm build:app 使用 HBuilderX 打开项目 云打包或本地打包 常见问题 路由生成失败 检查 src/pages.json 文件格式是否正确，确保 JSON 语法无误。 组件库样式问题 确保正确引入了 Wot Design Uni 的样式文件，检查 src/main.ts 中的导入。 请求失败 检查 src/config.ts 中的API地址配置，确保网络环境正常。 贡献指南 Fork 本仓库 创建特性分支 (git checkout -b feature/AmazingFeature) 提交更改 (git commit -m 'Add some AmazingFeature') 推送到分支 (git push origin feature/AmazingFeature) 打开 Pull Request 更新日志 v3.0.0 Monorepo + pnpm workspace 构建 集成 Vue 3 + TypeScript + Pinia 集成 Wot Design Uni 组件库 添加自动路由生成插件 添加页面监听插件 完整的请求封装和拦截器 丰富的Vue 3 Hooks工具库 阿里云OSS文件上传集成 完整的权限管理和登录流程 许可证 ISC 联系方式 如有问题或建议，请通过以下方式联系： 提交 Issue 发送邮件 参与讨论 ","link":"https://ihopefulchina.github.io/uniapp_template /"},{"title":"👉👉👉爬蓝湖原型目录结构","content":"本插件用于爬 蓝湖原型目录结构，导出csv文件，可以用于飞书等 开发项目在线文档。 原型 在公司发现一个痛点, 需求是这样的: 蓝湖原型，需要按照目录下来，然后生成飞书在线开发文档 传统上，只能手动copy 针对以上，写一个油猴脚本插件 爬蓝湖原型目录结构 主要特性 生成csv文件， 任务模块copy3份, 3种任务类型：[接口开发, 页面开发, 接口联调] ，如果有其他自定义，自行调整。 现已支持按钮拖拽，并缓存top，right位置信息，解决遮挡原型问题。 改成生成csv格式文件，兼容性更强，可以在飞书新建一个多维表格，然后选择导入Excel生成的文件。 后续支持 支持数据类型更丰富，比如添加开发人员信息 生成的Excel 导入到飞书 ","link":"https://ihopefulchina.github.io/qn_PbZX5g6/"},{"title":"自定义Hooks: usePullToRefresh(Vue3) - 列表组件中轻松实现下拉刷新和上拉加载更多功能","content":"在 Vue 3 中，我们可以通过自定义 Hook 来将业务逻辑从组件中抽离出来，使得我们的组件更加简洁和易于维护。今天，我们将介绍如何实现一个自定义的 PullToRefresh Hook，该 Hook 可以帮助我们在列表组件中轻松实现下拉刷新和上拉加载更多功能。 背景 在许多移动端应用或 Web 应用中，下拉刷新和上拉加载更多功能是非常常见的交互方式。为了实现这一功能，我们需要管理分页状态、加载状态、数据合并等多个方面的逻辑。通过使用 Vue 3 的组合式 API（Composition API），我们可以将这些逻辑封装成一个通用的 Hook，使得代码更加复用和易于维护。 需求分析 我们需要实现以下功能： • 支持下拉刷新和上拉加载更多。 • 支持分页加载，每次请求时，都会返回一页的数据。 • 支持数据的去重处理，防止加载重复的数据。 • 支持刷新时清空旧数据。 • 支持自定义数据格式化。 • 支持刷新完成后的回调，以便处理列表数据。 代码实现 下面是我们实现的 usePullToRefresh Hook 代码： import { computed, onMounted, ref } from 'vue'; import { useLockFn } from '~/hooks'; import { removeRepetition } from '~/utils'; export enum PullToRefreshState { /** * 普通状态 */ none, /** * 刷新中 */ refreshing, /** * 添加中 */ pushing, } export interface IPullRefreshHookRefreshParams { /** * 刷新时是否清空旧数组 * * @default false */ clearList?: boolean; } interface IUsePullToRefreshOption&lt;T&gt; { /** 默认数据 */ defaultData?: T[]; /** 默认初始插入数据 */ defaultInsertData?: T[]; dataKey?: string; /** 初始是否发出请求 */ initRequest?: boolean; /** 获取数据 */ getData: (data: Record&lt;string, any&gt; &amp; { pageNum: number }) =&gt; Promise&lt;{ data?: { list?: T[]; isLastPage?: boolean; total?: number } }&gt;; /** 数据格式化 */ dataFormat?(data: T[]): any[]; /** 获取数据完成回调，返回本次数据 */ onAfterLoad?(data: T[], currentParams: Record&lt;string, any&gt; &amp; { pageNum: number }, total: number, isLastPage: boolean): void; /** 获取数据完成回调，返回当前list、currentParams */ customSpliceList?(list: T[], currentParams: Record&lt;string, any&gt; &amp; { pageNum: number }): void; } export default function usePullToRefresh&lt;T&gt;(config: IUsePullToRefreshOption&lt;T&gt;) { const { defaultData = [], dataKey = 'id' } = config; const list = ref&lt;any[]&gt;(defaultData); const total = ref&lt;number&gt;(0); const noMore = ref&lt;boolean&gt;(false); const pullToRefreshState = ref&lt;PullToRefreshState&gt;(PullToRefreshState.refreshing); const requestId = ref&lt;number&gt;(0); const pageNum = ref&lt;number&gt;(0); const getListData = useLockFn(async (num?: number) =&gt; { if (num !== undefined) { pageNum.value = num; } else { pageNum.value++; } if (pageNum.value === 1) { pullToRefreshState.value = PullToRefreshState.refreshing; // setData([]); } else { pullToRefreshState.value = PullToRefreshState.pushing; } try { const currentRequestId = ++requestId.value; const currentParams = { pageNum: pageNum.value, pageSize: 10 }; const { data = {} } = await config.getData(currentParams); if (currentRequestId !== requestId.value) { return; } // eslint-disable-next-line prefer-const let { list: dataList = [], isLastPage } = data; dataList = config.dataFormat ? config.dataFormat(dataList) : dataList; if (config.onAfterLoad) { config.onAfterLoad(dataList, currentParams, data?.total || -1, !!isLastPage); } if (pageNum.value === 1) { list.value = (config.defaultInsertData ? [...config.defaultInsertData, ...dataList] : dataList) || []; } else { dataList = removeRepetition((list.value || []) ?.concat(dataList), dataKey); list.value = dataList; } if (config.customSpliceList) { config.customSpliceList(dataList, currentParams); } total.value = data?.total || -1; noMore.value = isLastPage !== undefined ? !!isLastPage : data?.total !== -1 ? dataList?.length &gt;= (data?.total || -1) : true; } catch (error) { if (pageNum.value === 1) { list.value = []; } } pullToRefreshState.value = PullToRefreshState.none; }); /** * 更新某条数据的值 * * @param updatedata */ function updateById(updatedata: T, key = 'id') { const newList = [...list.value]?.map((value) =&gt; { if ((value as any)[key] === (updatedata as any)[key]) { /** 改成替换更新 */ return { ...updatedata }; } return { ...value }; }); list.value = [...newList]; } /** * 删除某条数据的值 * * @param id */ function deleteById(id: number | string, key = 'id') { list.value = list.value?.filter((item) =&gt; `${item[key]}` !== `${id}`); } /** * 更新列表中的数据 * * @param {T} data 需要更新的数据 * @param {(string | ((item: T, index: number) =&gt; boolean))} compare 比对逻辑 */ function updateLisItem(data: T, compare: string | ((item: T, index: number) =&gt; boolean)) { const isString = typeof compare === 'string'; list.value = list.value?.map((value, index) =&gt; { if (isString) { return (value as any)[compare] === (data as any)[compare] ? { ...value, ...data } : value; } return compare(value, index) ? { ...value, ...data } : value; }); } onMounted(() =&gt; { if (config?.initRequest !== false) { getListData(); } }); function onRefresh(refreshParams?: IPullRefreshHookRefreshParams) { if (refreshParams?.clearList) { list.value = []; } getListData(1); } const isEmpty = computed(() =&gt; list?.value.length === 0 &amp;&amp; pullToRefreshState?.value === PullToRefreshState.none); return { list, setList: list.value, total, updateById, pageNum, updateLisItem, deleteByIndex: (index: number) =&gt; (list.value = list.value ?.filter((__, idx) =&gt; idx !== index)), /** 根据传入的标识删除对应的数据，传入标识值和标识字段，默认id */ deleteById, state: pullToRefreshState, noMore, onRefresh, isEmpty, onReachBottom: () =&gt; getListData(), }; } 使用实例 // 列表数据 const pullToProps = useMMPullToRefresh&lt;UpWorkHistoryPageVO&gt;({ initRequest: false, getData: (params) =&gt; { if (type.value === EStaffBillPermission.REPAIR) { return api['/wechat/api/repairWorkOrderSignHistory/page_GET'] ({ ...params, id: pageQuery?.value?.id }); } return api['/wechat/api/upWorkOrder/historyPage_GET'] ({ ...params, id: pageQuery?.value?.id, type: ESignInType.SIGN_IN }); }, }); const { list, isEmpty } = toRefs(pullToProps); &lt;PullToRefresh :noMore=&quot;pullToProps?.noMore&quot; :state=&quot;pullToProps?.state&quot; :isEmpty=&quot;pullToProps?.isEmpty&quot; @onRefresh=&quot;pullToProps?.onRefresh&quot; @onReachBottom=&quot;pullToProps?.onReachBottom&quot; refresherBackground=&quot;#fff&quot; &gt; &lt;view class=&quot;list&quot; v-if=&quot;list &amp;&amp; list?.length &gt; 0&quot;&gt; &lt;view class=&quot;item&quot; v-for=&quot;item in list&quot; :key=&quot;item?.id&quot;&gt; &lt;Item :item=&quot;item&quot; :type=&quot;type&quot; /&gt; &lt;/view&gt; &lt;/view&gt; &lt;view v-else-if=&quot;isEmpty&quot;&gt; &lt;Empty marginTop=&quot;440&quot; :emptyStr=&quot;t('common.no_data')&quot; /&gt; &lt;/view&gt; &lt;/PullToRefresh&gt; ``` PullToRefresh 组件源码(仅供参考，相关逻辑根据项目实际业务场景) import { CSSProperties, ComputedRef, Ref, computed, getCurrentInstance, onMounted, ref, toRefs } from 'vue'; import Gap from '~/components/common/gap/Gap.vue'; import { useLockFn } from '~/hooks'; import { useSystemInfo } from '~/state/useSystemInfo'; import TnLoadmore from '~/uni_modules/tuniaoui-vue3/components/loadmore/src/loadmore.vue'; import { selectRect } from '~/utils/uniApi'; import { MMPullToRefreshState } from './const'; /** 设置自定义下拉刷新阈值 */ const REFRESHER_THRESHOLD = 45; interface IMMPullToRefreshProps { /** 刷新状态 */ state: Ref; /** 没有更多 */ noMore: Ref; /** 是否显示没有更多文案，默认显示 */ hiddeNoMoreText?: boolean; /** 是否空数据 */ isEmpty?: ComputedRef; /** 列表高度 */ height?: number; /** styles */ styles?: CSSProperties; /** isTab */ isTab?: boolean; /** 背景颜色 */ refresherBackground?: string; /** 底部空间高度 rpx */ footerSpace?: number; /** 页面滚动回掉 */ onScroll?: (e: any) => void; } /** 子传父事件 */ const emits = defineEmits<{ (e: 'onRefresh'): void; (e: 'onReachBottom'): void; }>(); const systemInfo = useSystemInfo(); const instance = getCurrentInstance(); // 获取组件实例 /** 父传子参数 */ const props = defineProps(); const { noMore, state, isEmpty } = toRefs(props); /** 列表高度计算 */ const scollViewHeight = ref(); const calculateScrollViewHeight = async () => { let scrollViewHeight = props?.height; try { if (!scrollViewHeight) { const topViewRes: any = await selectRect('#MMPullToRefreshTop', instance!); scrollViewHeight = systemInfo?.screenHeight - topViewRes?.top; } } catch (error) { console.warn(error); } scollViewHeight.value = props?.isTab && scrollViewHeight ? scrollViewHeight - systemInfo?.tabbarHeight : scrollViewHeight; }; onMounted(() => { calculateScrollViewHeight(); }); /** 加载更多status */ const status = computed<'loading' | 'nomore' | undefined>(() => { if (state?.value === MMPullToRefreshState.pushing) { return 'loading'; } else if (state.value !== MMPullToRefreshState.refreshing && noMore) { return 'nomore'; } return undefined; }); /** 开启自定义下拉刷新 */ // const refresherTriggered = computed(() => state?.value === MMPullToRefreshState.refreshing); const refresherTriggered = ref(false); /** 刷新列表 */ const refresherrefresh = useLockFn(async () => { refresherTriggered.value = true; if (state.value === MMPullToRefreshState.none) { emits('onRefresh'); setTimeout(() => { refresherTriggered.value = false; }, 500); } }); const onScroll = (event: any) => { props.onScroll?.(event); }; /** 下拉更多 */ const scrolltolower = () => { if (!noMore?.value) { emits('onReachBottom'); } }; &lt;view class=&quot;noMore&quot; v-if=&quot;!isEmpty &amp;&amp; (status !== 'nomore' || (status === 'nomore' &amp;&amp; !props.hiddeNoMoreText))&quot;&gt; &lt;TnLoadmore :status=&quot;status&quot; v-if=&quot;status&quot; color=&quot;#999&quot; loadingIconMode=&quot;flower&quot; /&gt; &lt;/view&gt; &lt;Gap :height=&quot;props?.footerSpace&quot; v-if=&quot;props?.footerSpace&quot; :styles=&quot;{ width: '100%' }&quot; /&gt; &lt;/scroll-view&gt; &lt;/view&gt; @import './index.scss'; ","link":"https://ihopefulchina.github.io/4PEcn6ZhYy/"},{"title":"自定义Hooks: useMutate(Vue3) - 简单的获取数据方法的一个封装","content":"在 Vue 3 中，组合式 API（Composition API）为我们提供了更灵活的方式来组织代码。今天，我们将实现一个通用的 useMutate Hook，用于处理数据请求并更新组件中的数据状态。这个 Hook 将帮助我们封装数据获取、格式化、状态管理等逻辑，从而使得组件更简洁且易于复用。 背景 在前端开发中，数据的请求和展示是常见的功能。为了避免在每个组件中重复相似的代码，我们可以将数据请求的逻辑抽象成一个可复用的 Hook。useMutate Hook 的目标就是封装数据请求、处理无数据状态和格式化数据的逻辑，帮助我们简化代码并提高开发效率。 需求分析 我们需要实现以下功能： 1. 数据请求： 向服务器请求数据。 2. 数据格式化： 支持自定义的数据格式化函数。 3. 请求成功回调： 请求成功后触发回调，方便后续操作。 4. 无数据状态管理： 判断返回数据是否为空，并更新 noData 状态。 代码实现 下面是我们实现的 useMutate Hook： import { onMounted, ref } from 'vue'; import { useLockFn } from './useLockFn'; interface IMutateOption&lt;T&gt; { /** 默认数据 */ defaultData?: T; /** 额外传递参数 */ params?: Record&lt;string, any&gt;; /** 初始是否发出请求 */ initRequest?: boolean; /** 获取数据 */ getData: (data: Record&lt;string, any&gt;) =&gt; Promise&lt;{ data?: T }&gt;; /** 数据格式化 */ dataFormat?(data?: T): any; /** 请求成功后的回调 */ successCallback?(data?: T): void; } export function useMutate&lt;T&gt;(config: IMutateOption&lt;T&gt;) { const { defaultData, params, initRequest = true } = config; const detail = ref&lt;T | undefined&gt;(defaultData); const noData = ref&lt;boolean&gt;(); const isInit = ref(initRequest); const mutate = useLockFn(async () =&gt; { try { const { data } = await config.getData({ ...params }); const newData = config.dataFormat ? config.dataFormat(data) : data; detail.value = newData; config?.successCallback?.(newData); /**暂无数据 */ let blo = false; if (newData !== undefined) { if (newData instanceof Array) { blo = newData.length === 0; } else if (newData instanceof Object) { blo = Object.keys(newData).length === 0; } } else { blo = true; } noData.value = blo; } catch (error) { console.log(error); noData.value = true; } }, 500); onMounted(() =&gt; { if (!isInit.value) { isInit.value = true; } else { mutate(); } }); return { mutate, detail, noData }; } 使用示例 const { detail, mutate, noData } = useMutate({ getData: () =&gt; api['/wechat/api/outWorkOrder/express/{id}_GET'](1), }); ","link":"https://ihopefulchina.github.io/aJA508HwI4/"},{"title":"自定义Hooks: useProTableRequest —— Ant Design Pro Table 请求封装","content":"在开发中，我们常常需要处理表格数据的请求、缓存、导出等功能。为了提高代码的复用性和简洁性，我们可以将这些逻辑封装到一个自定义 Hook 中。本文将介绍一个基于 Ant Design Pro Table 的表格请求封装 Hook —— useProTableRequest，并深入讲解其工作原理和如何在项目中使用。 功能概述 useProTableRequest 是一个用于处理表格数据请求的自定义 Hook，主要包括以下功能： • 数据请求：从服务器获取数据，并支持分页、排序和筛选功能。 • 数据缓存：缓存请求的参数和数据，方便在用户返回该页面时恢复表格状态（如分页、筛选等）。 • 参数格式化：可以自定义格式化请求参数和返回的数据 代码code import { ActionType, ProFormInstance, RequestData } from '@ant-design/pro-components' import { SortOrder } from 'antd/lib/table/interface' import React, { useCallback, useEffect, useLayoutEffect, useRef } from 'react' type Params&lt;U&gt; = U &amp; { pageSize?: number current?: number keyword?: string } type Sort = Record&lt;string, SortOrder&gt; type Filter = Record&lt;string, React.ReactText[] | null&gt; type Fn&lt;U, T&gt; = ( params: any, sort: Sort, filter: Filter ) =&gt; Promise&lt;{ code?: number; msg?: string; data?: { list?: T[]; total?: number } }&gt; export interface IUseProTableRequestOption&lt;T, U = T&gt; { /** 需要缓存的目标链接地址 * 目的: 缓存列表页的请求参数，例如分页、排序、搜索等参数，方便详情回列表页时自动恢复 * @example [routeNames.userManagementUserListUserDetail] */ cacheUrls?: string[] /** * 格式化数据 * 你可以对返回的数据做一些处理 */ dataFormat?: (data: T[]) =&gt; U[] /** * 格式化参数 * * 前置处理请求参数。如果你需要传递给导出时。这会很有用 * @param params 将要传递给接口的参数 */ paramsFormat?(params: any): any } /** * antd pro table请求封装钩子 * @param fn * @param option * @returns */ export default function useProTableRequest&lt;T, U extends Record&lt;string, any&gt; = {}&gt;( fn: Fn&lt;U, T&gt;, option: IUseProTableRequestOption&lt;T&gt; = {} ) { const { dataFormat, cacheUrls } = option // Table action 的引用，便于自定义触发 const actionRef = useRef&lt;ActionType&gt;() const formRef = useRef&lt;ProFormInstance&gt;() // 缓存请求参数 const requestParams = useRef&lt;Record&lt;string, any&gt;&gt;({}) // 数据缓存参数 const dataSourceRef = useRef&lt;T[]&gt;([]) /** 缓存参数 */ const _cacheData = useRef&lt;any&gt;(undefined) /** 缓存key */ const cacheKey = genCacheKey() /** 当前是否需要缓存 */ const needCache = !!cacheUrls?.length // 表格请求 const tableRequst = useCallback(async (params: Params&lt;U&gt;, sort: Sort, filter: Filter) =&gt; { const { current, ...rest } = params as Record&lt;string, any&gt; const newParams: any = { ...rest, pageNum: current ?? params?.pageNum ?? 1 } // 重置数据 let total = 0 let data: T[] = [] requestParams.current = option.paramsFormat ? option.paramsFormat(newParams) : newParams try { // 参数长度过长不处理 if (JSON.stringify(requestParams.current).length &lt; 1000) { const res = await fn(requestParams.current, sort, filter) // 如果当前列表为空并且pageNum不为1.则重新发起请求 if (!res.data?.list?.length &amp;&amp; requestParams.current.pageNum !== 1) { setTimeout(() =&gt; { actionRef.current?.reload(true) }) } const { list = [] as T[] } = res.data || {} total = res.data?.total || 0 data = dataFormat ? dataFormat(list) : list // 缓存数据 _cacheData.current = { ...requestParams.current } dataSourceRef.current = data } } catch (error) {} // } return { data, success: true, total } as Partial&lt;RequestData&lt;T&gt;&gt; }, []) /** 恢复缓存 */ const restoreCache = () =&gt; { if (needCache) { const cacheString = window.sessionStorage.getItem(cacheKey) if (cacheString) { try { const cacheParams = JSON.parse(cacheString) /** 恢复请求参数 */ _cacheData.current = cacheParams /** 恢复搜索表单 */ formRef.current?.setFieldsValue(cacheParams) /** 恢复分页信息 */ actionRef.current?.setPageInfo?.({ current: cacheParams?.current ?? cacheParams?.pageNum ?? 1, pageSize: cacheParams?.pageSize }) } catch (error) { } finally { window.sessionStorage.removeItem(cacheKey) // 清除缓存数据 } } } } useLayoutEffect(() =&gt; { restoreCache() }, []) /** * 表格数据缓存处理 */ useEffect(() =&gt; { return () =&gt; { if (!needCache) { return } // 组件卸载时将数据缓存至sessionStorage const to = pick(window.location, ['hash', 'href', 'protocol', 'port', 'search', 'pathname', 'hostname']) const toCache = cacheUrls?.some((url) =&gt; to?.href?.includes(url)) if (toCache) { window.sessionStorage.setItem(cacheKey, JSON.stringify(_cacheData.current)) } } }, []) return { formRef, actionRef, /** * 表格请求 */ request: tableRequst, /** * 表格query参数 */ params: requestParams, /** * 表格数据缓存 */ dataSource: dataSourceRef } } /** * 从对象中选择指定的属性 * @param obj * @param keys * @returns */ function pick&lt;T extends Object, K extends keyof T&gt;(obj: T, keys: K[]): Pick&lt;T, K&gt; { const result = {} as Pick&lt;T, K&gt; keys.forEach((key) =&gt; { if (key in obj) { result[key] = obj[key] } }) return result } /** * 生成缓存键值 * @param key key * @returns */ function genCacheKey(key?: string | ((ok: string) =&gt; string)) { const hostKey = encodeURIComponent(window.location.href.replace(/http(s)?:\\/\\//, '')) if (typeof key === 'function') { return key(hostKey) } return key || hostKey } 简单实例 const { request, actionRef, formRef } = useProTableRequest(api['/admin/mall/banner/queryList_GET']) ","link":"https://ihopefulchina.github.io/vrE64S-kvU/"},{"title":"插件: 自动生成 Vue 3 项目中的路由配置","content":"在开发大型应用时，手动管理路由配置文件可能会非常繁琐且容易出错。特别是在多页面应用或使用分包的项目中，页面和路由路径可能会不断增加或变化。如果每次都手动更新路由配置文件，开发效率将会大大降低。 我写了一个如何通过自动化脚本生成 Vue 3 项目的路由配置文件。具体来说，将根据 pages.json 文件动态生成路由映射，并且支持分包和 tabBar 配置。 背景 在某些小程序框架（如 Taro 或 WeChat 小程序）中，路由配置是通过 pages.json 文件来维护的。这个文件定义了页面的路径、tabBar 配置、分包等信息。为了提高开发效率，我们希望能够自动从 pages.json 文件中读取这些信息，并生成对应的路由配置文件，而不需要手动去编写。 实现思路 我们可以编写一个 Node.js 脚本，它会： 1. 读取 pages.json 文件。 2. 提取主包和分包的页面路由信息。 3. 生成符合 Vue 3 项目路由要求的配置。 4. 自动生成一个 TypeScript 文件来保存路由映射。 代码实现 我们通过以下脚本实现自动生成路由配置的功能： /* eslint-disable id-length */ /* eslint-disable @typescript-eslint/no-var-requires */ const fs = require('fs'); const pagesJson = require('../src/pages.json'); const tabBar = (pagesJson?.tabBar ?? [])?.list.map((item) =&gt; ({ url: `/${item.pagePath}` })); const mainPages = pagesJson?.pages?.map((it) =&gt; ({ name: it.name || '', path: it.path })); const subPackages = []; /** 获取分包的路由 */ pagesJson?.subPackages ?.map((it) =&gt; { if (it.pages) { return it.pages.map((vl) =&gt; ({ name: vl.name || '', path: it.root + '/' + vl.path })); } }) ?.map((it) =&gt; { if (it) { subPackages.push(...it); } }); const pages = [...mainPages, ...subPackages]; // 所有路由 const tab = ' '; let str = ` /** * 页面路由映射. * 请不要在此文件添加任何代码。因为生成后会全量覆盖 * 运行 npm run route 或者 yarn route 自动生成 */ export const routeNames = {\\n`; str += pages .map(({ name, path }, index) =&gt; { const key = path.replace(/^\\//, '').replace(/\\/([a-zA-Z0-9])/g, (_m, p) =&gt; p.toUpperCase()); return `${tab}${tab}/** ${name} */\\n${tab}${tab}${key}: '/${path}'${index !== pages.length - 1 ? ',' : ''}`; }) .join('\\n'); str += '\\n};\\n\\n'; if (tabBar.length) { str += 'export const tabbar = ' + JSON.stringify(tabBar, undefined, 4) .replace(/&quot;(.+)&quot;:/g, '$1:') .replace(/: &quot;(.+)&quot;/g, &quot;:'$1'&quot;); str += ';\\n\\n'; } fs.writeFile('./src/routes.ts', str, (error) =&gt; { // 创建失败 if (error) { console.log(`生成失败❌：${error}`); } // 创建成功 console.log('🎉🎉🎉🎉路由生成✅'); }); 如何使用 将上述脚本文件保存为 generate-routes.js，并放置在项目的根目录中。 在 package.json 中添加一个脚本命令来执行这个脚本： &quot;scripts&quot;: { &quot;route&quot;: &quot;node generate-routes.js&quot; } 运行命令生成路由配置： npm run route 总结 通过这个自动化脚本，我们能够轻松地根据 pages.json 文件生成项目中的路由配置。这大大提高了开发效率，避免了手动维护路由的繁琐工作。每当 pages.json 文件更新时，我们只需重新运行脚本，路由配置就会自动更新。 ","link":"https://ihopefulchina.github.io/ZxMrztTo35/"},{"title":"🙋🙋🙋AvatarCropper: 头像裁剪组件","content":"在这篇文章中，我们将深入探讨如何实现一个头像裁剪组件 (AvatarCropper)，它不仅可以裁剪图片，还能处理缩放、旋转等操作。该组件基于 Taro 框架构建，可以在多种环境中运行（如微信、支付宝小程序和Web）。我们将分析其核心功能，结构，以及如何使用它。 组件概述 AvatarCropper 是一个用户自定义的头像裁剪工具，允许用户选择图片进行裁剪，支持缩放、旋转、拖动等操作。组件的功能包括： • 选择图片进行裁剪。 • 支持缩放和旋转图像。 • 在画布上实时显示裁剪效果。 • 裁剪完成后，可以返回裁剪后的图片或文件路径。 组件属性解析 AvatarCropper 的一些常见属性： • maxZoom：最大缩放倍数，控制裁剪区域的最大缩放程度。 • space：裁剪框与画布边缘的空隙，避免裁剪框被画布边界限制。 • toolbar：裁剪工具栏的内容，可以自定义显示的按钮。 • toolbarPosition：工具栏的位置，支持 top 或 bottom。 • editText：显示在裁剪工具栏的编辑文字。 • sizeType 和 sourceType：允许选择图片的类型和来源。 • shape：裁剪框的形状，支持 square 或 round。 • onConfirm：裁剪完成后的回调函数，传递裁剪后的图片路径。 • onCancel：取消裁剪的回调函数。 代码 index.less code .avatar-cropper { position: relative; display: flex; &amp;-edit-text { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: #000; z-index: 1; color: #fff; display: flex; justify-content: center; align-items: center; } &amp;-input { position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0; // 隐藏原生上传按钮 cursor: pointer; z-index: 2; } &amp;-popup { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: #000; z-index: 1000; &amp;-canvas, &amp;-cut-canvas { position: absolute; bottom: 0; left: 0; width: 100%; height: 100%; z-index: 1; } &amp;-cut-canvas { z-index: 0; } &amp;-toolbar { position: absolute; bottom: 30px; left: 0; width: 100%; z-index: 2; &amp;.top { top: 0; bottom: inherit; } &amp;-flex { width: 100%; display: flex; justify-content: space-between; } &amp;-item { // flex: 1; color: #fff; padding: 10px 30px; cursor: pointer; display: flex; align-items: center; } } &amp;-highlight { position: absolute; left: 0; top: 0; width: 100%; height: 100%; z-index: 1; background-color: transparent; .highlight { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); background-color: transparent; // box-shadow: 0 0 1000px 1000px rgba(0, 0, 0, 0.6); } } } &amp;.round { .nut-avatar-cropper-edit-text { border-radius: 50%; } } } [dir='rtl'] .avatar-cropper, .nut-rtl .avatar-cropper { &amp;-edit-text { left: auto; right: 0; } &amp;-input { left: auto; right: 0; } &amp;-popup { left: auto; right: 0; &amp;-canvas, &amp;-cut-canvas { left: auto; right: 0; } &amp;-toolbar { left: auto; right: 0; } &amp;-highlight { left: auto; right: 0; .highlight { left: auto; right: 50%; transform: translate(50%, -50%); } } } } .canvans-btn { font-size: 13px; color: #fff; font-weight: 400; display: flex; justify-content: center; align-items: center; cursor: pointer; } index.tsx code import { AvatarCropper } from './avatarcropper' export type { AvatarCropperProps, AvatarCropperToolbarPosition, AvatarCropperSizeType, AvatarCropperSourceType, AvatarCropperShape } from './avatarcropper' export default AvatarCropper type.ts code import type { CSSProperties, ReactNode } from 'react' export interface BasicComponent { className?: string style?: CSSProperties children?: ReactNode id?: string } export const ComponentDefaults = { className: '', style: {} } use-touch.ts code import React, { useRef } from 'react' const MIN_DISTANCE = 10 type Direction = '' | 'vertical' | 'horizontal' function getDirection(x: number, y: number) { if (x &gt; y &amp;&amp; x &gt; MIN_DISTANCE) { return 'horizontal' } if (y &gt; x &amp;&amp; y &gt; MIN_DISTANCE) { return 'vertical' } return '' } export function useTouch() { const startX = useRef(0) const startY = useRef(0) const deltaX = useRef(0) const deltaY = useRef(0) const delta = useRef(0) const offsetX = useRef(0) const offsetY = useRef(0) const direction = useRef&lt;Direction&gt;('') const last = useRef(false) const velocity = useRef(0) const touchTime = useRef&lt;number&gt;(Date.now()) const isVertical = () =&gt; direction.current === 'vertical' const isHorizontal = () =&gt; direction.current === 'horizontal' const reset = () =&gt; { touchTime.current = Date.now() deltaX.current = 0 deltaY.current = 0 offsetX.current = 0 offsetY.current = 0 delta.current = 0 direction.current = '' last.current = false } const start = (event: React.TouchEvent&lt;HTMLElement&gt;) =&gt; { reset() touchTime.current = Date.now() startX.current = event.touches[0].clientX startY.current = event.touches[0].clientY } const move = (event: React.TouchEvent&lt;HTMLElement&gt;) =&gt; { const touch = event.touches[0] // Fix: Safari back will set clientX to negative number deltaX.current = touch.clientX &lt; 0 ? 0 : touch.clientX - startX.current deltaY.current = touch.clientY - startY.current offsetX.current = Math.abs(deltaX.current) offsetY.current = Math.abs(deltaY.current) delta.current = isVertical() ? deltaY.current : deltaX.current if (!direction.current) { direction.current = getDirection(offsetX.current, offsetY.current) } } const end = (event: React.TouchEvent&lt;HTMLElement&gt;) =&gt; { last.current = true velocity.current = Math.sqrt(deltaX.current ** 2 + deltaY.current ** 2) / (Date.now() - touchTime.current) } return { end, move, start, reset, touchTime, startX, startY, deltaX, deltaY, delta, offsetX, offsetY, direction, isVertical, isHorizontal, last } } utils.ts code export const isObject = (val: unknown): val is Record&lt;any, any&gt; =&gt; val !== null &amp;&amp; typeof val === 'object' // eslint-disable-next-line @typescript-eslint/ban-types export const isFunction = (val: unknown): val is Function =&gt; typeof val === 'function' export const isPromise = &lt;T = any&gt;(val: unknown): val is Promise&lt;T&gt; =&gt; { return isObject(val) &amp;&amp; isFunction(val.then) &amp;&amp; isFunction(val.catch) } export const upperCaseFirst = (str: string) =&gt; { str = str.toLowerCase() str = str.replace(/\\b\\w+\\b/g, (word) =&gt; word.substring(0, 1).toUpperCase() + word.substring(1)) return str } export const clamp = (num: number, min: number, max: number): number =&gt; Math.min(Math.max(num, min), max) export function preventDefault(event: React.TouchEvent&lt;HTMLElement&gt; | TouchEvent, isStopPropagation?: boolean) { if (typeof event.cancelable !== 'boolean' || event.cancelable) { event.preventDefault() } if (isStopPropagation) { event.stopPropagation() } } 简单实例 &lt;AvatarCropper shape=&quot;round&quot; onConfirm={cutImage}&gt; &lt;View className={styles.headImgCenter}&gt; {!!headImg &amp;&amp; &lt;Image className={styles.headImg} src={headImg ?? ''} mode=&quot;aspectFill&quot; /&gt;} &lt;/View&gt; &lt;/AvatarCropper&gt; TODO 相关核心逻辑 ","link":"https://ihopefulchina.github.io/7dtD7wCIDd/"},{"title":"自定义Hooks: useRouterParams(Web) - 获取 URL 中的查询参数","content":"在 React 中，我们经常需要获取和处理 URL 中的查询参数。特别是在单页应用（SPA）中，路由参数的管理和转换非常常见。为了提高代码的复用性和可维护性，我们可以使用 React 的 Hook 来封装这类逻辑，确保代码简洁、易于维护。通过实现一个自定义的 useRouterParams Hook 来演示如何获取 URL 中的查询参数，并根据需求进行解析和转换。 背景 在前端开发中，路由查询参数（Query Parameters）是非常常见的。例如，在一个电商平台中，可能会通过 URL 的查询参数来传递过滤条件（如类别、价格区间等）。对于多页面应用（MPA）或单页面应用（SPA），获取和处理这些参数是必不可少的操作。 React 官方提供的 useLocation 和 useHistory 钩子可以帮助我们访问路由，但它们默认只返回完整的 URL 信息，没有直接提供对查询参数的处理。因此，我们需要编写一个自定义 Hook 来简化这个过程。 实现思路 我们希望创建一个 useRouterParams 的 Hook，它具有以下功能： • 获取当前页面的查询参数。 • 可以选择对查询参数进行转换（例如，转换为数值类型或枚举类型）。 • 提供一种简便的方式来访问和管理查询参数。 代码实现 下面是 useRouterParams Hook 的实现代码： import { useMemo } from 'react' export type DefaultParams = Partial&lt;Record&lt;string, string&gt;&gt; /** * 获取路由参数。 * 这个钩子允许开发者类型化路由参数，并可选地提供一个解析函数来处理参数。 * * @param option.parseFn 解析函数。默认路由参数都是string类型。有些时候你需要转换成其他类型(数值/枚举)等。你可以通过传递这个参数来处理参数。 * */ export function useRouterParams&lt;T = DefaultParams&gt;( option: { transform?: (data: T) =&gt; T } = {} ) { const url = new URL(window.location.href) const params = getQueryParams(url?.href) as T const _param = useMemo(() =&gt; { // 计算key let cparam: T = params as T try { if (option.transform) cparam = option.transform(cparam) } catch (event) { // eslint-disable-next-line no-console console.error('parseFn 执行失败:', event) } return { ...params, ...cparam } as T }, [params]) return [_param as T] as const } // 正则表达式提取查询字符串 function getQueryParams(url: string): Record&lt;string, string&gt; { const queryString = url.split('?')[1] || '' const params: Record&lt;string, string&gt; = {} // 匹配所有的 key=value 对 queryString.replace(/([^=&amp;]+)=([^&amp;]*)/g, (_match, key, value) =&gt; { params[decodeURIComponent(key)] = decodeURIComponent(value) return '' }) return params } 简单实例 ","link":"https://ihopefulchina.github.io/p9E7d0w867/"},{"title":"自定义Hooks: useLockFn(Vue3) - 防止频繁触发函数调用","content":"在现代前端开发中，防止用户快速重复点击按钮或执行某些操作是一个常见的需求。例如，用户在短时间内连续点击按钮时，我们可能只想执行第一次点击的操作，而忽略后续的重复点击。 为了解决这个问题，我们可以使用一个 锁定机制 来防止函数的多次调用。本文将介绍如何使用 Vue 3 中的 ref 和 async 函数来实现一个 useLockFn 自定义 Hook，它可以防止在短时间内重复执行一个异步操作。 需求分析 有些操作可能会被频繁触发，比如： • 用户多次点击按钮发起网络请求。 • 连续调用同一个函数导致重复操作（例如，表单提交、数据保存等）。 为了避免这种重复操作，我们需要引入 锁机制，确保同一时刻只执行一次函数。 useLockFn 的实现 useLockFn 是一个高阶函数，它接受一个异步函数 fn 和一个可选的延迟 delay（默认为 600 毫秒）。它返回一个新函数，该函数会： • 防止在指定的延迟时间内重复调用。 • 在异步操作完成前，锁住该函数，避免重复执行。 import { ref } from 'vue'; type ArgsAny = any[]; type Fn = (...args: ArgsAny) =&gt; Promise&lt;any&gt;; export const useLockFn = (fn: Fn, delay = 600) =&gt; { const lock = ref(false); const lastDate = ref(); return async (...args: ArgsAny) =&gt; { if (lock.value) return; const nowDate = new Date(); if (lastDate?.value &amp;&amp; nowDate.getTime() - lastDate?.value.getTime() &lt;= delay) { return; } lastDate.value = nowDate; lock.value = true; try { const ret = await fn(...args); lock.value = false; return ret; } catch (error) { lock.value = false; throw error; } }; }; ","link":"https://ihopefulchina.github.io/mHHMm1wDV3/"},{"title":"自定义Hooks: useRowSelection - ProTable 选择项配置hooks","content":"在写基于Antd Pro 后台业务的时候，发现一个高频业务场景需求： 表格列表多选item的时候，没办法跨分页选择。 我写一个自定义Hooks，支持跨分页选择。 import { TableProps } from 'antd' import { useState } from 'react' export interface UseRowSelectionResult&lt;T&gt; { /** key */ rowKey: string /** 选择项配置 */ rowSelection?: | (TableProps&lt;T&gt;['rowSelection'] &amp; { alwaysShowAlert?: boolean }) | false /** 选择项选中id合集 */ selectedRowKeys: number[] /** 批量选择items */ selectedRows: T[] /** 选择项更新 */ setSelectedRows: (list: T[]) =&gt; void } export interface UseRowSelectionParams&lt;T&gt; { /** @name 选择项Key值 */ rowKey?: string /** @name 选择项配置 */ rowSelection?: TableProps&lt;T&gt;['rowSelection'] /** 选中项更新 */ onChange?: (list: T[], ids: number[]) =&gt; void } /** hooks - ProTable 选择项配置hooks */ export function useRowSelection&lt;T&gt;(props?: UseRowSelectionParams&lt;T&gt;): UseRowSelectionResult&lt;T&gt; { const rowKey = props?.rowKey ?? 'id' const rowSelection = props?.rowSelection /** 批量选择items */ const [selectedRows, setSelectedRows] = useState&lt;T[]&gt;([]) /** 选择项选中id合集 */ const selectedRowKeys = (selectedRows || []).map((row) =&gt; row[rowKey]) /** 选择项配置 */ const newRowSelection = { ...rowSelection, type: rowSelection?.type ?? 'checkbox', selectedRowKeys, onSelect: (item: any, blo) =&gt; { if (blo) { if (rowSelection?.type === 'radio') { setSelectedRows([{ ...item }]) } else { setSelectedRows([...selectedRows, { ...item }]) } } else { setSelectedRows(selectedRows.filter((row) =&gt; row[rowKey] !== item?.[rowKey])) } }, onSelectAll: (blo, rows, changeRows) =&gt; { if (blo) { setSelectedRows([...selectedRows, ...changeRows]) } else { if (selectedRows?.length) { const newList = selectedRows?.filter((item) =&gt; !changeRows?.find((row) =&gt; row[rowKey] === item[rowKey])) setSelectedRows(newList) } else { setSelectedRows([]) } } }, onChange: (selectedRowKeys, selectedRows, info) =&gt; { if (info?.type === 'none') { setSelectedRows(selectedRows) props?.onChange?.(selectedRowKeys, selectedRows) } } } return { /** key */ rowKey, /** 选择项配置 */ rowSelection: newRowSelection, /** 选择项选中id合集 */ selectedRowKeys, /** 批量选择items */ selectedRows, /** 选择项更新 */ setSelectedRows } } 使用方法实例: /** ProTable 选择项配置 */ const { rowSelection, selectedRows, setSelectedRows } = useRowSelection&lt;MallCouponTemplateResVO&gt;({ ...props.rowSelectionProps }) &lt;ProTable rowSelection={rowSelection} /&gt; ","link":"https://ihopefulchina.github.io/KIr9bupcA9/"},{"title":"自定义Hooks: useMutate - 简单的获取数据方法的一个封装","content":"在写React 项目业务过程中，经常写一些 相似的代码逻辑。 比如我需要在进入页面请求接口数据 传统上我们请求接口获取数据，大概类似这样： /** 数据 */ const [detail, setDetail] = useState(defaultData) /** 请求数据 */ const mutate = async () =&gt; { try { const { data } = await config.getData({ ...params }) setDetail(data) } catch (error) {} } useEffect(() =&gt; { mutate() }, []) 对于这类相关的业务逻辑，我写了一个自定义hooks /** hooks - 对于简单的获取数据方法的一个封装 */ import { useState, useRef, useEffect, useMemo } from 'react' interface IMutateOption&lt;T&gt; { /** 默认数据 */ defaultData?: T /** 额外传递参数 */ params?: Record&lt;string, any&gt; /** 初始是否发出请求 */ initRequest?: boolean /** 获取数据 */ getData: (data: Record&lt;string, any&gt;) =&gt; Promise&lt;{ data?: T }&gt; /** 数据格式化 */ dataFormat?(data?: T): any /** 请求成功后的回调 */ successCallback?(data?: T): void } export function useMutate&lt;T&gt;(config: IMutateOption&lt;T&gt;) { const { defaultData, params, initRequest = true } = config /** 数据 */ const [detail, setDetail] = useState(defaultData) /** 是否初始化 */ const isInit = useRef(initRequest) let loading = false /** 请求数据 */ const mutate = async () =&gt; { try { loading = true const { data } = await config.getData({ ...params }) const newData = config.dataFormat ? config.dataFormat(data) : data setDetail(newData) config?.successCallback?.(newData) return newData } catch (error) { setDetail({}) } finally { loading = false } } /** 初始请求 */ useEffect(() =&gt; { if (!isInit.current) { isInit.current = true } else { mutate() } }, []) /** 暂无数据 */ const noData = useMemo(() =&gt; { if (detail !== undefined) { if (detail instanceof Array) { return detail.length === 0 } else if (detail instanceof Object) { return Object.keys(detail).length === 0 } } return false }, [detail]) return { mutate, detail, setDetail, noData, loading } } 获取数据类似逻辑简单封装 ","link":"https://ihopefulchina.github.io/481vcXjEdn/"},{"title":"taro SwipeCell 滑动单元格组件","content":"基于Taro3、React的 taro SwipeCell 滑动单元格组件 复用性很低，主要提供一个思路， 使用ScrollView 会有在部分真机设备有兼容性问题；使用MovableView方式页面滑动就会有问题，目前这样思路是最优解决方案。 安装 npm install taro-swipe-cell 导入组件 import MySwipeCell from 'taro-swipe-cell' 参数说明 参数 描述 类型 必传 默认值 deleteItem 删除事件 Function 是 () =&gt; void children children React.children 是 使用 import { FC, memo } from 'react' import MySwipeCell from 'taro-swipe-cell' import Taro from '@tarojs/taro' import { View } from '@tarojs/components' const Component: FC = () =&gt; { // 删除当前item const delItem = item =&gt; { } return ( &lt;&gt; &lt;MySwipeCell deleteItem={() =&gt; delItem(item)}&gt; &lt;View className={styles.item}&gt; 1111 &lt;/View&gt; &lt;/MySwipeCell&gt; &lt;/&gt; ) } const Mall = memo(Component) export default Mall ","link":"https://ihopefulchina.github.io/0ZUzQJonb/"},{"title":"huangpengfei-js-tools","content":"huangpengfei-js-tools 整理工作中常用的JavaScript、Taro、Hooks方法合集 安装 npm install huangpengfei-js-tools 引入方法 import { xxx } from 'huangpengfei-js-tools' 用例 /* 组件 -- 官方多列选择器使用 */ import { memo } from 'react' import Taro from '@tarojs/taro' import { Picker } from '@tarojs/components' import { useFile2Txt, useMultiSelectorTree } from 'huangpengfei-js-tools' interface IProps { children: any onChange: any value: any disabled?: boolean } const Component = ({ children, value, onChange, disabled }: IProps) =&gt; { const rangeKey = 'value' const { nodes = [] as any } = useFile2Txt(jsonUrl) const { valueIndex, range, onColumnChange, onCancel } = useMultiSelectorTree({ value, list: nodes, depth: 3, rangeKey }) // 点击 const onChangeCity = event =&gt; { const { value: values } = event?.detail if (onChange) { const item = values.map((it, index) =&gt; { return range[index][it] }) onChange(item) } } return ( &lt;Picker mode=&quot;multiSelector&quot; range={range} value={valueIndex} disabled={disabled} onCancel={onCancel} onColumnChange={onColumnChange} onChange={onChangeCity} rangeKey={rangeKey} &gt; {children} &lt;/Picker&gt; ) } export default memo(Component) ","link":"https://ihopefulchina.github.io/odFd8wVk4/"},{"title":"Taro Parabola","content":"taro-parabola 基于Taro3、React的H5和微信小程序添加到购物车抛物线动画组件 安装 npm install taro-parabola 导入组件 import Parabola from 'taro-parabola' 参数说明 参数 描述 类型 必传 默认值 cartX 购物车 所在坐标的x值 number 是 screenWidth cartY 购物车 所在坐标的y值 number 是 screenHeight - 60 onChange 点击回调方法 Function 否 () =&gt; void parabolaStyle 抛物线样式 React.CSSProperties 否 使用 import { FC, memo, useEffect, useState } from 'react' import Parabola from 'taro-parabola' import Taro from '@tarojs/taro' import { View } from '@tarojs/components' const list = [1, 2, 3, 4, 5] const Component: FC = () =&gt; { const [cartInfo, setCartInfo] = useState({} as any) return ( &lt;&gt; {list.map(item =&gt; ( &lt;Parabola cartX={cartInfo.left} cartY={cartInfo.top} parabolaStyle={{ width: '15px', height: '15px', backgroundColor: '#333' }} onChange={() =&gt; {}} key={item} &gt; {item} &lt;/Parabola&gt; ))} &lt;View id=&quot;cart&quot;&gt;我是购物车&lt;/View&gt; &lt;/&gt; ) } const Mall = memo(Component) export default Mall ","link":"https://ihopefulchina.github.io/taro-parabola/"},{"title":"封装腾讯即时通讯 for 小程序","content":"适用小程序(Taro)接入腾讯即时通讯。 贴下Github地址：https://github.com/ihopefulChina/tim-for-weapp-Taro 参考资料 SDK API（Web &amp; 小程序） 微信小程序原生接入腾讯云im 原生JS集成腾讯IM实时聊天/实时音视频 微信小程序利用腾讯云IM即时通讯发送文字+表情开发） import Taro from &quot;@tarojs/taro&quot;; import TIM from 'tim-wx-sdk'; import COS from &quot;cos-wx-sdk-v5&quot; import TIMUploadPlugin from 'tim-upload-plugin'; import roomStore from &quot;~/store/room&quot;; import timStore from '~/store/tim' //sdk import { timSDK } from &quot;~/config&quot; import { get } from &quot;~/components/request&quot;; const userInfo = (Taro.getStorageSync('userInfo')) as any; // 初始化 const iminit_TIM = async () =&gt; { const options = { SDKAppID: timSDK // 接入时需要将0替换为您的即时通信 IM 应用的 SDKAppID } // 创建 SDK 实例，`TIM.create()`方法对于同一个 `SDKAppID` 只会返回同一份实例 const tim = TIM.create(options);// SDK 实例通常用 tim 表示 // 设置 SDK 日志输出级别，详细分级请参见 setLogLevel 接口的说明 // tim.setLogLevel(0); // 普通级别，日志量较多，接入时建议使用 tim.setLogLevel(1); // release 级别，SDK 输出关键信息，生产环境时建议使用 // 注册 COS SDK 插件 tim.registerPlugin({ 'cos-wx-sdk': COS }) tim.registerPlugin({ 'tim-upload-plugin': TIMUploadPlugin }); // 监听事件，例如： tim.on(TIM.EVENT.SDK_READY, (event) =&gt; { timStore.isImLogin = true Taro.setStorageSync('isImLogin', true) // @ts-ignore // eslint-disable-next-line no-undef wx.event.emit('SDK_ready', event.name) // 收到离线消息和会话列表同步完毕通知，接入侧可以调用 sendMessage 等需要鉴权的接口 // event.name - TIM.EVENT.SDK_READY }); tim.on(TIM.EVENT.MESSAGE_RECEIVED, (event) =&gt; { // 若同时收到多个会话 需要根据conversationID来判断是哪个人的会话 const msgarr = [] as any const newMsgForm = event.data[0].conversationID // 定义会话键值 if (msgarr[newMsgForm]) { msgarr[newMsgForm].push(event.data[0]) } else { msgarr[newMsgForm] = [event.data[0]] } timStore.myMessages = msgarr // 这里引入了一个监听器 （因为小程序没有类似vuex的状态管理器 当global里面的数据变化时不能及时同步到聊天页面 因此 这个监听器可以emit一个方法 到需要更新会话数据的页面 在那里进行赋值） // @ts-ignore // eslint-disable-next-line no-undef wx.event.emit('testFunc', msgarr, newMsgForm) // 详情页的函数 // 收到推送的单聊、群聊、群提示、群系统通知的新消息，可通过遍历 event.data 获取消息列表数据并渲染到页面 // event.name - TIM.EVENT.MESSAGE_RECEIVED // event.data - 存储 Message 对象的数组 - [Message] }) tim.on(TIM.EVENT.MESSAGE_READ_BY_PEER, (event) =&gt; { // SDK 收到对端已读消息的通知，即已读回执。使用前需要将 SDK 版本升级至 v2.7.0 或以上。仅支持单聊会话。 const msgarr = [] as any const newMsgForm = event.data[0].conversationID // 定义会话键值 if (msgarr[newMsgForm]) { msgarr[newMsgForm].push(event.data[0]) } else { msgarr[newMsgForm] = [event.data[0]] } // @ts-ignore // eslint-disable-next-line no-undef wx.event.emit('readItem', msgarr, newMsgForm) // 函数 // event.name - TIM.EVENT.MESSAGE_READ_BY_PEER // event.data - event.data - 存储 Message 对象的数组 - [Message] - 每个 Message 对象的 isPeerRead 属性值为 true }); tim.on(TIM.EVENT.CONVERSATION_LIST_UPDATED, (event) =&gt; { // 更新当前所有会话列表 // 注意 这个函数在首次点击进入会话列表的时候也会执行 因此点击消息 可以显示当前的未读消息数（unreadCount表示未读数） timStore.isImLogin &amp;&amp; initRecentContactList() // 收到会话列表更新通知，可通过遍历 event.data 获取会话列表数据并渲染到页面 // event.name - TIM.EVENT.CONVERSATION_LIST_UPDATED // event.data - 存储 Conversation 对象的数组 - [Conversation] }); tim.on(TIM.EVENT.SDK_NOT_READY, (event) =&gt; { timStore.isImLogin = false Taro.setStorageSync('isImLogin', false) loginIm_TIM(userInfo.adventureNo) // @ts-ignore // eslint-disable-next-line no-undef wx.event.emit('SDK_no_ready', event.name) // 收到 SDK 进入 not ready 状态通知，此时 SDK 无法正常工作 // event.name - TIM.EVENT.SDK_NOT_READY }); tim.on(TIM.EVENT.KICKED_OUT, (event) =&gt; { Taro.setStorageSync('isImLogin', false) timStore.isImLogin = false; // 收到被踢下线通知 // event.name - TIM.EVENT.KICKED_OUT // event.data.type - 被踢下线的原因，例如: // - TIM.TYPES.KICKED_OUT_MULT_ACCOUNT 多实例登录被踢 // - TIM.TYPES.KICKED_OUT_MULT_DEVICE 多终端登录被踢 // - TIM.TYPES.KICKED_OUT_USERSIG_EXPIRED 签名过期被踢 }) timStore.tim = tim; } // 登录 const loginIm_TIM = userID =&gt; { const id = userID ? userID : userInfo.adventureNo if (!!id &amp;&amp; !timStore.isImLogin) { // 开始登录 get(`/im/getUserSign?adventureNo=${id}`).then(res =&gt; { Taro.setStorageSync('userSig', res.data) const promise = timStore.tim.login({ userID: String(id), userSig: res.data }); promise.then((imResponse) =&gt; { Taro.setStorageSync('isImLogin', true) timStore.isImLogin = true setTimeout(() =&gt; { // 拉取会话列表 timStore.isImLogin &amp;&amp; initRecentContactList() }, 1000); }).catch((imError) =&gt; { // Taro.showToast({ // title: 'login error' + imError, // icon: 'none', // duration: 3000 // }) }); }) } } // 会话列表 const initRecentContactList = () =&gt; { const promise = timStore.tim.getConversationList(); if (!promise) { // Taro.showToast({ // title: 'SDK not ready', // icon: 'none', // duration: 3000 // }) return } let conversationList = [] as any promise.then((imResponse) =&gt; { // 如果最后一条消息是自定义消息的话，处理一下data conversationList = imResponse.data.conversationList; // 会话列表，用该列表覆盖原有的会话列表 conversationList.forEach(event =&gt; { if (event.lastMessage.type === 'TIMCustomElem') { const data = event.lastMessage.payload.data let new_data = '' if (typeof (data) === 'string' &amp;&amp; data) { new_data = JSON.parse(data) } event.lastMessage.payload.data = new_data } }) let number = 0 conversationList.forEach(ele =&gt; { number = number + ele.unreadCount }) // console.log('initRecentContactList', number) //更新获取未读消息角标 采用了mbox方式传入 roomStore.updateRoomNum(number) const list = conversationList as any // @ts-ignore // eslint-disable-next-line no-undef wx.event.emit('conversationList', list) // 函数 timStore.conversationList = list Taro.setStorageSync('conversationList', list) }).catch((imError) =&gt; { // Taro.showToast({ // title: 'getConversationList error:' + imError, // icon: 'none', // duration: 3000 // }) }) } // 删除会话 function deleteConversation_TIM(ID) { const promise = timStore.tim.deleteConversation(ID); promise.then((imResponse) =&gt; { // 删除成功。 const { conversationID } = imResponse.data;// 被删除的会话 ID const oldList = Taro.getStorageSync('conversationList') const newList = oldList.filter((item: any) =&gt; conversationID !== item.conversationID) Taro.setStorageSync('conversationList', newList) }) } export { iminit_TIM, loginIm_TIM, initRecentContactList, deleteConversation_TIM } 获取列表 hooks方式 const [list, setList] = useState([] as any); useEffect(() =&gt; { // @ts-ignore // eslint-disable-next-line no-undef wx.event.on(&quot;conversationList&quot;, (lists: any) =&gt; { if (lists.length &gt; 0) { timStore.isImLogin &amp;&amp; setList( lists ? lists : timStore.conversationList ); } }); }, []); 获取聊天会话 // 发送信息 const [sendMsg, setSendMsg] = useState(&quot;&quot; as any); // im实时聊天数据 const [toView, setToView] = useState(&quot;&quot; as any); // 用于续拉，分页续拉时需传入该字段。 const [nextReqMessageID, setNextReqMessageID] = useState(&quot;&quot; as any); // 表示是否已经拉完所有消息。 const [isCompleted, setIsCompleted] = useState(&quot;&quot; as any); // 消息列表 const [myMessages, setmyMessages] = useState([] as any); const [more_text, setmore_text] = useState(&quot;&quot;); const [is_lock, setis_lock] = useState(true); // 语音操作 const [title, settitle] = useState(&quot;正在录音&quot;); const [isRecording, setisRecording] = useState(false); // 拉取会话列表 const getMsgList = () =&gt; { const param = { //sendId 为对方id conversationID: &quot;C2C&quot; + sendId, count: 15, nextReqMessageID }; const promise = timStore.tim.getMessageList(param); promise .then(imResponse =&gt; { const messageList = imResponse.data.messageList; // 消息列表。 // 处理自定义的消息 messageList.forEach(event =&gt; { if (event.type === &quot;TIMCustomElem&quot;) { if (typeof event.payload.data === &quot;string&quot; &amp;&amp; event.payload.data) { const new_data = JSON.parse(event.payload.data); event.payload.data = new_data; } } }); const newNextReqMessageID = imResponse.data.nextReqMessageID; // 用于续拉，分页续拉时需传入该字段。 const newIsCompleted = imResponse.data.isCompleted; // 表示是否已经拉完所有消息。 // 将某会话下所有未读消息已读上报 setMessageRead(); setmyMessages(messageList); setIsCompleted(newIsCompleted); setNextReqMessageID(newNextReqMessageID); setmore_text(newIsCompleted ? &quot;没有更多了&quot; : &quot;下拉查看更多历史信息&quot;); scrollToBottom(messageList.length - 1); }) .catch(imError =&gt; { // console.warn(&quot;getConversationList error:&quot;, imError); // 获取会话列表失败的相关信息 }); }; 已读回执 // 已读回执 // @ts-ignore // eslint-disable-next-line no-undef wx.event.on(&quot;readItem&quot;, (ele, newMsgForm) =&gt; { if (newMsgForm === `C2C${sendId}` &amp;&amp; timStore.isDetail) { const newmsg = ele[`C2C${sendId}`]; const oldItems = deepCopy(myMessages); if (newmsg) { newmsg.forEach(event =&gt; { if (event.type === &quot;TIMCustomElem&quot;) { if (typeof event.payload.data === &quot;string&quot; &amp;&amp; event.payload.data) { const new_data = JSON.parse(event.payload.data); event.payload.data = new_data; } } }); let newitems = oldItems.filter( (item: any) =&gt; !newmsg.some((dom: any) =&gt; dom.ID === item.ID) ); newitems = [...newitems, ...newmsg]; setmyMessages(newitems); scrollToBottom(newitems.length - 1); } } }); 接受到新消息 // @ts-ignore // eslint-disable-next-line no-undef wx.event.on(&quot;testFunc&quot;, (ele, newMsgForm) =&gt; { if (newMsgForm === `C2C${sendId}` &amp;&amp; timStore.isDetail) { const newmsg = ele[`C2C${sendId}`]; let oldMss = myMessages; if (newmsg) { newmsg.forEach(event =&gt; { if (event.type === &quot;TIMCustomElem&quot;) { if ( typeof event.payload.data === &quot;string&quot; &amp;&amp; event.payload.data ) { const new_data = JSON.parse(event.payload.data); event.payload.data = new_data; } } if (!event.isRead) { oldMss = [...oldMss, ...newmsg]; } }); setmyMessages(oldMss); scrollToBottom(oldMss.length - 1); } setMessageRead(); } }); 设置已读上报 const setMessageRead = () =&gt; { const promise = timStore.tim.setMessageRead({ conversationID: &quot;C2C&quot; + sendId }); promise .then(imResponse =&gt; { initRecentContactList(); // 已读上报成功 let noready = 0; const messages = myMessages as any; messages.forEach(event =&gt; { if (!event.isRead) { noready++; } }); const number = Taro.getStorageSync(&quot;number_msg&quot;); const newNumber = number - noready; Taro.setStorageSync(&quot;number_msg&quot;, newNumber); roomStore.updateRoomNum(newNumber); }) .catch(imError =&gt; { // 已读上报失败 // console.warn(&quot;setMessageRead error:&quot;, imError); }); }; 发送文本消息 // 发送普通文本消息 const bindConfirm = () =&gt; { if (is_lock) { setis_lock(false); if (sendMsg.length === 0) { Taro.showToast({ title: &quot;消息不能为空!&quot;, icon: &quot;none&quot; }); setis_lock(true); return; } const content = { text: sendMsg }; const options = { to: sendId, // 消息的接收方 conversationType: TIM.TYPES.CONV_C2C, // 会话类型取值timStore.tim.TYPES.CONV_C2C或timStore.tim.TYPES.CONV_GROUP payload: content // 消息内容的容器 }; // // 发送文本消息，Web 端与小程序端相同 // 1. 创建消息实例，接口返回的实例可以上屏 const message = timStore.tim.createTextMessage(options); // 2. 发送消息 sendMessageFun(message, &quot;text&quot;); } }; 发送语音图片和视频消息 // 发送语音消息 const bindAudioMessage = res =&gt; { // 4. 创建消息实例，接口返回的实例可以上屏 const message = timStore.tim.createAudioMessage({ to: sendId, // 消息的接收方 conversationType: TIM.TYPES.CONV_C2C, payload: { file: res } }); sendMessageFun(message, &quot;voice&quot;); }; // 发送视频 const createVideoMessage = res =&gt; { // 2. 创建消息实例，接口返回的实例可以上屏 const message = timStore.tim.createVideoMessage({ to: sendId, conversationType: TIM.TYPES.CONV_C2C, payload: { file: res } }); // 3. 发送消息 sendMessageFun(message, &quot;video&quot;); }; // 发送图片 const createImageMessage = res =&gt; { const message = timStore.tim.createImageMessage({ to: sendId, conversationType: TIM.TYPES.CONV_C2C, payload: { file: res }, onProgress(event) { setProgress(event); } }); sendMessageFun(message, &quot;image&quot;); }; 发送消息封装 const sendMessageFun = (message, type) =&gt; { Taro.showLoading({ title: &quot;发送中&quot; }); const promise = timStore.tim.sendMessage(message); promise.then(imResponse =&gt; { // 发送成功 setMessageRead(); const messageList = myMessages as any; messageList.push(imResponse.data.message); setis_lock(true); setmyMessages(messageList); clearInput(); scrollToBottom(messageList.length - 1); Taro.hideLoading({}); }); }; ","link":"https://ihopefulchina.github.io/IZbWBmM7v/"},{"title":"腾讯COS上传图片封装","content":"cos-js-sdk-v5 封装 适用于微信浏览器H5环境 Github地址：https://github.com/ihopefulChina/Tencent-COS-uploads-picture config.ts import { genID, get_suffix } from '~/tools/tools'; import { autobind } from 'core-decorators'; import COS from 'cos-js-sdk-v5'; const Bucket = 'Bucket值'; const Region = 'Region值'; @autobind export default class COSUpload { private getOssToken: () =&gt; Promise&lt;any&gt; constructor(config: { getOssToken: () =&gt; Promise&lt;any&gt; }) { this.getOssToken = config.getOssToken; } /** * 批量上传 * @param {Object} obj Bucket、Region、Body 详情查看cos文档 * @returns err || 批量上传filesData */ uploadFiles(fileList: any) { // eslint-disable-next-line no-async-promise-executor return new Promise(async (resolve, reject) =&gt; { const { cos, content } = await this.getOss(); const files = await fileList.map((fileObject: any) =&gt; { const file = fileObject.file ? fileObject.file : fileObject; const fileName = `${content.requestId}${genID(3)}.${file.path ? get_suffix(file.path) : 'png'}`; return { Bucket: Bucket, Region: Region, Key: fileName, StorageClass: 'STANDARD', Body: file, }; }); await cos.uploadFiles({ files, SliceSize: 1024 * 1024 * 5, /* 设置大于5MB采用分块上传 */ }, function (err: any, data: any) { const val = (err || data); const list = !err ? val.files.map((item: any) =&gt; `https://${item.data.Location}` ) : []; const newArr = list.filter((it: string) =&gt; it); return err ? reject(err) : resolve(newArr); }); }); } private async getOss() { const data = await this.getOssToken(); const content = data as any; const credentials = data.credentials; // console.log(window,wx); const cos = new COS({ getAuthorization: function (options: any, callback: any) { callback({ TmpSecretId: credentials.tmpSecretId, TmpSecretKey: credentials.tmpSecretKey, SecurityToken: credentials.sessionToken, // 建议返回服务器时间作为签名的开始时间，避免用户浏览器本地时间偏差过大导致签名错误 StartTime: data.startTime, // 时间戳，单位秒，如：1580000000 ExpiredTime: data.expiredTime, // 时间戳，单位秒，如：1580000900 }); } }); return { cos, content }; } } index.ts import COSUpload from './config'; import { get } from &quot;~/request&quot;; &lt;!-- get请求 --&gt; const { uploadFiles } = new COSUpload({ getOssToken: () =&gt; get(`xxx.com/tencent/cos-token`) }); export { uploadFiles }; 引入文件内容 /** * @description: 生成唯一id * @param {number} length 数字长度 * @return {string} */ export function genID(length = 3) { return Number(Math.random().toString().substr(3, length) + Date.now()).toString(36); } //获取文件名称后缀 export const get_suffix = (fileName: string) =&gt; { const suffix = fileName.substring(fileName.lastIndexOf('.') + 1); return suffix; }; 上传多张图片组件 /* 组件 -- 上传 */ import React, { useState } from &quot;react&quot;; import WxImageViewer from &quot;react-wx-images-viewer&quot;; import { uploadFiles } from &quot;~/components/tencent&quot;; import { Toast } from &quot;antd-mobile&quot;; import Compressor from &quot;compressorjs&quot;; import styles from &quot;./index.module.less&quot;; interface IProps { imgList?: string[]; onChange: (list: string[]) =&gt; void; onDelete: (idx: number) =&gt; void; progressChange?: (percent: number) =&gt; void; count?: number; } const Index = ({ imgList = [], onChange, onDelete, count = 2 }: IProps) =&gt; { const [showViewer, setShowViewer] = useState(false); const [imgIndex, setImgIndex] = useState(0); const onInputChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; { const fileList = e.target.files; if (imgList.length &lt; count) { //代表还可以上传 if (fileList &amp;&amp; fileList.length &gt; 0) { const newFileList = [] as any; for (const key in fileList) { if (Object.prototype.hasOwnProperty.call(fileList, key)) { const element = fileList[key] as any; element &amp;&amp; newFileList.push(element); } } let paths = []; if (imgList.length + newFileList.length &lt; count) { paths = newFileList; } else { //数量超过了 const surplus = count - imgList.length; paths = newFileList.slice(0, surplus); // paths = newFileList.filter((item, index) =&gt; index &lt; surplus); } //压缩图片 const newPaths = paths.map((image: any) =&gt; { let newImg = image; new Compressor(image, { quality: 0.5, // 0.6 can also be used, but its not recommended to go below. success: (res) =&gt; (newImg = res), }); return newImg; }); Toast.loading(&quot;上传中...&quot;); uploadFiles(newPaths).then((res: any) =&gt; { onChange &amp;&amp; onChange([...imgList, ...res]); Toast.hide(); }); } } }; return ( &lt;div className={styles.upload}&gt; &lt;div className={styles.uploadList}&gt; {imgList.map((item, index) =&gt; ( &lt;div key={`${item}`} className={styles.item} onClick={(event) =&gt; { event.stopPropagation(); setShowViewer(true); setImgIndex(index); document .getElementsByTagName(&quot;body&quot;)[0] .setAttribute(&quot;style&quot;, &quot;overflow:hidden&quot;); //给body添加overflow:hidden阻止遮罩层滚动主页面滚动 }} &gt; &lt;img className={styles.img} data-preview-proto={item} src={item} alt=&quot;上传图片&quot; /&gt; &lt;img className={styles.del} src={require(&quot;./images/del.png&quot;)} alt=&quot;删除按钮&quot; onClick={(event) =&gt; { event.stopPropagation(); onDelete(index); }} /&gt; &lt;/div&gt; ))} {imgList.length &lt; count &amp;&amp; ( &lt;div className={styles.uploadBtn}&gt; &lt;input type=&quot;file&quot; name=&quot;image&quot; accept=&quot;image/*&quot; multiple={true} className={styles.uploadInput} onChange={onInputChange} /&gt; &lt;div className={styles.uploadPlus}&gt; &lt;img src={require(&quot;./images/plus.png&quot;)} alt=&quot;加号&quot; /&gt; &lt;span&gt; ({imgList.length}/{count}) &lt;/span&gt; &lt;/div&gt; &lt;/div&gt; )} &lt;/div&gt; {showViewer ? ( &lt;WxImageViewer onClose={() =&gt; { setShowViewer(false); document.getElementsByTagName(&quot;body&quot;)[0].removeAttribute(&quot;style&quot;); }} urls={imgList} index={imgIndex} /&gt; ) : ( &quot;&quot; )} &lt;/div&gt; ); }; export default Index; 引用组件 import Upload from &quot;~/components/upload&quot;; &lt;Upload imgList={form.discoverServiceImgs} count={6} onChange={(imgs) =&gt; setForm({ ...form, discoverServiceImgs: imgs }) } onDelete={(idx) =&gt; setForm({ ...form, discoverServiceImgs: form.discoverServiceImgs.filter( (_value: any, _index: any) =&gt; _index !== idx ), }) } /&gt; ","link":"https://ihopefulchina.github.io/oi4CnmXh7/"},{"title":"函数式组件与类组件有何不同？","content":" 函数式组件捕获了渲染所用的值。（Function components capture the rendered values.） 作者是 Dan Abramov , Facebook React 核心开发，Redux 作者 博客地址 https://overreacted.io/zh-hans/how-are-function-components-different-from-classes/ ","link":"https://ihopefulchina.github.io/dBAsSzkYF/"},{"title":"获取当前分类下的所有子分类","content":"一般用于taxonomy分类页面，比如产品products，下面有a这个分类，a下面有a-1,a-2,a-3... 如何在进入a分类这个页面的时候，输出这个a下面的子分类？ 解决思路: 1.首先通过get_categories获取所有分类的slug和id $test = get_categories(&quot;taxonomy=product&amp;hide_empty=0&quot;); $cats=array(); foreach($test as $tmpcat){ if($tmpcat-&gt;parent==0){ $cats[$tmpcat-&gt;term_id]['slug']=$tmpcat-&gt;slug; $cats[$tmpcat-&gt;term_id]['term_id']=$tmpcat-&gt;term_id; } } 3.然后切割分组当前url，判断slug是否等于当前的url $uri=explode('/',$_SERVER['REQUEST_URI']); 5.等于的话，再根据get_categories加上child_of=，最后foreach输出所有分类。 foreach($cats as $key=&gt;$val){ if($cats[$key]['slug']==$uri[2]){ $id = $cats[$key]['term_id']; $cate = get_categories(&quot;depth=0&amp;hide_empty=0&amp;title_li=&amp;orderby=ID&amp;order=ASC&amp;taxonomy=product&amp;child_of=$id&quot;); foreach ($cate as $key =&gt; $value) {?&gt; &lt;div class=&quot;swiper-slide&quot;&gt; &lt;li class=&quot;cat-item&lt;?php if($value-&gt;slug == $uri[3]){ echo ' current-cat';}?&gt;&quot;&gt;&lt;a href=&quot;/products/&lt;?php echo $uri[2];?&gt;/&lt;?php echo $value-&gt;slug; ?&gt;/&quot;&gt;&lt;?php echo $value-&gt;name;?&gt;&lt;/a&gt;&lt;/li&gt; &lt;/div&gt; &lt;?php } } } 完整的 &lt;?php $test = get_categories(&quot;taxonomy=product&amp;hide_empty=0&quot;); $cats=array(); foreach($test as $tmpcat){ if($tmpcat-&gt;parent==0){ $cats[$tmpcat-&gt;term_id]['slug']=$tmpcat-&gt;slug; $cats[$tmpcat-&gt;term_id]['term_id']=$tmpcat-&gt;term_id; } } foreach($cats as $key=&gt;$val){ if($cats[$key]['slug']==$uri[2]){ $id = $cats[$key]['term_id']; $cate = get_categories(&quot;depth=0&amp;hide_empty=0&amp;title_li=&amp;orderby=ID&amp;order=ASC&amp;taxonomy=product&amp;child_of=$id&quot;); foreach ($cate as $key =&gt; $value) {?&gt; &lt;div class=&quot;swiper-slide&quot;&gt; &lt;li class=&quot;cat-item&lt;?php if($value-&gt;slug == $uri[3]){ echo ' current-cat';}?&gt;&quot;&gt;&lt;a href=&quot;/products/&lt;?php echo $uri[2];?&gt;/&lt;?php echo $value-&gt;slug; ?&gt;/&quot;&gt;&lt;?php echo $value-&gt;name;?&gt;&lt;/a&gt;&lt;/li&gt; &lt;/div&gt; &lt;?php } } } ?&gt; ","link":"https://ihopefulchina.github.io/huo-qu-dang-qian-fen-lei-xia-de-suo-you-zi-fen-lei/"},{"title":"如何解决页面/文章/详情页需要不同样式、模板的问题？","content":"遇到一个客户，他的需求是在产品详情页有5套不同的模板，需要在后台自己可以选择不同模板，填写不同的内容。 一开始知道这个需求很懵，后来我理清楚了思路，解决了这个问题: 首先通过ACF插件Seclect的单选按钮，填写5个参数 (注: 参数' : '前后需要有空格) 通过ACF插件的组来写5个模板(组下面填写不同的自定义字段) 注: (1)需要填写判断(条件逻辑) (2)其中每个模板Group里面的说明最好加上模板图片样式，例如&lt;img src=&quot;/wp-admin/images/sj.png&quot; width=&quot;50%&quot; height=&quot;auto&quot;&gt; 这么做的目的，是客户知道这是哪个模板样式，呈现的效果如下。 3.然后创建5个php，命名规避page，single等等自带的命名方式，里面填写各自模板样式和参数。 5.最后在single-products.php里面，加一个判断: &lt;?php if( get_field('select') == 'one' ): ?&gt; &lt;?php include 'product-content1.php'; ?&gt; &lt;?php endif; ?&gt; &lt;?php if( get_field('select') == 'two' ): ?&gt; &lt;?php include 'product-content2.php'; ?&gt; &lt;?php endif; ?&gt; &lt;?php if( get_field('select') == 'three' ): ?&gt; &lt;?php include 'product-content3.php'; ?&gt; &lt;?php endif; ?&gt; &lt;?php if( get_field('select') == 'four' ): ?&gt; &lt;?php include 'product-content4.php'; ?&gt; &lt;?php endif; ?&gt; &lt;?php if( get_field('select') == 'five' ): ?&gt; &lt;?php include 'product-content5.php'; ?&gt; &lt;?php endif; ?&gt; 其中的one，two... 来自ACF插件Seclect的单选按钮前面的参数 ","link":"https://ihopefulchina.github.io/ru-he-jie-jue-ye-mian-wen-zhang-xiang-qing-ye-xu-yao-bu-tong-yang-shi-mo-ban-de-wen-ti/"},{"title":"留言表单、支持邮箱转发","content":"基于PHP搭建，用于Wordpress的插件 项目地址:https://github.com/ihopefulChina/Message (已设为私有，无法访问，如果有需要联系:hpf784667332@gmail.com) 功能介绍: 后台有留言管理，支持留言删除、标记。 支持过虑垃圾留言，Akismet API提供API支持。 留言自动转发邮箱，抄送邮箱。 支持查询客户的IP地址，根据IP地址查找客户所在国家、地区。 支持客户留言所在网址、留言时间、设备信息等等。 支持自定义表单name标签内容。 ","link":"https://ihopefulchina.github.io/liu-yan-biao-dan-zhi-chi-you-xiang-zhuan-fa/"},{"title":"如何输出根据分类罗列文章，当前页面高亮显示","content":"我之前有写过类似这个功能，这次写的全一点，高亮显示实现功能也是用到这个$uri=explode('/',$_SERVER['REQUEST_URI']); 我贴一下代码，你们可以参考一下，个人暂时未找到更好的方法，有什么好的方法，可以在下面评论，我们探讨一下。 $uri=explode('/',$_SERVER['REQUEST_URI']); &lt;?php $categories = get_categories(&quot;hierarchical=1&amp;taxonomy=video&amp;hide_empty=0&quot;); $cats=array(); foreach($categories as $tmpcat){ if($tmpcat-&gt;parent&gt;0){ $cats[$tmpcat-&gt;parent]['child'][$tmpcat-&gt;term_id]['name']=$tmpcat-&gt;name; $cats[$tmpcat-&gt;parent]['child'][$tmpcat-&gt;term_id]['term_id']=$tmpcat-&gt;term_id; }else{ $cats[$tmpcat-&gt;term_id]['name']=$tmpcat-&gt;name; $cats[$tmpcat-&gt;term_id]['term_id']=$tmpcat-&gt;term_id; } } ksort($cats); foreach($cats as $key=&gt;$val){?&gt; &lt;li class=&quot;cat-item&quot;&gt; &lt;i class=&quot;fas fa-angle-down&quot;&gt;&lt;/i&gt;&lt;a&gt;&lt;?php echo $val[&quot;name&quot;]; ?&gt;&lt;/a&gt; &lt;ul class=&quot;children&quot;&gt; &lt;?php foreach($val[&quot;child&quot;] as $cat){ ?&gt; &lt;li class=&quot;cat-item&quot;&gt; &lt;a&lt;?php if (ucwords(str_replace('-',' ',$uri[3])) == $cat[&quot;name&quot;] ) {echo ' class=&quot;opeth&quot;';}?&gt;&gt;&lt;?php echo $cat[&quot;name&quot;]; ?&gt;&lt;/a&gt; &lt;?php $posts_array = get_posts( array( 'posts_per_page' =&gt; 3, 'post_type' =&gt; 'videos', 'tax_query' =&gt; array( array( 'taxonomy' =&gt; 'video', 'field' =&gt; 'term_id', 'terms' =&gt; $cat['term_id'], ) ) ) ); if ($posts_array){?&gt; &lt;ul class=&quot;children&quot;&gt; &lt;?php foreach( $posts_array as $post ){ $youtube = substr(basename(get_field('add_link')),8); $a = substr(strrchr(rtrim(get_permalink(), '/'), '/'), 1);?&gt; &lt;li&lt;?php if ($uri[4] == $a ) {echo ' class=&quot;opeth&quot;';} ?&gt;&gt; &lt;div class=&quot;list-video&quot;&gt; &lt;div class=&quot;col-md-4&quot;&gt; &lt;iframe width=&quot;100%&quot; height=&quot;45px&quot; src=&quot;https://www.youtube.com/embed/&lt;?php echo $youtube;?&gt;&quot; frameborder=&quot;0&quot; showinfo=&quot;0&quot;&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;div class=&quot;col-md-8&quot;&gt; &lt;a href=&quot;&lt;?php echo get_permalink(); ?&gt;&quot;&gt;&lt;?php echo get_the_title(); ?&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;clearfix&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;?php } ?&gt; &lt;/ul&gt; &lt;?php } ?&gt; &lt;/li&gt; &lt;?php } ?&gt; &lt;/ul&gt; &lt;/li&gt; &lt;?php } ?&gt; ","link":"https://ihopefulchina.github.io/ru-he-shu-chu-gen-ju-fen-lei-luo-lie-wen-zhang-dang-qian-ye-mian-gao-liang-xian-shi/"},{"title":"如何用TAG方式串联自定义分类(实现相关文章串联功能)","content":"遇到过一个奇葩的客户，让我通过TAG的方式，获取自定义分类的相关文章。 例如:某产品写了a这个tag标签，某新闻、案例、应用等等都有一个一样是a标签，然后如何在这个产品详情页，输出含有a标签的相关新闻、相关案例、相关应用等等。 最后如果没有这个标签的话，后台有通过手动添加功能填写 听到这里估计大家都蒙了，Wordprss不支持这个功能，没有插件支持这个功能，经过一系列摸索，我解决了这个问题，这里给大家解决思路。 首先在自定义分类添加tag标签'taxonomies' =&gt; array('post_tag')，官方文档。 添加完成后，需要用到ACF插件的关系，这个是如果没有这个标签的话，后台有通过手动添加功能填写功能 3.在前台填写判断，如果ACF关系的值为空的话，输出标签串联的相关文章，不为空的话，为手动添加的相关文章。 Demo: &lt;?php /** * Related Applications */ $posts = get_field('related-applications'); if( $posts ): ?&gt; &lt;div class=&quot;product_details_left_applications product_details_left_standards&quot;&gt; &lt;div class=&quot;product_details_left_applications_title&quot;&gt;Related Applications&lt;/div&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;?php foreach( $posts as $id ): $image = get_field('application-image',$id); if(empty($image)) $image['sizes']['thumbnail']='/wp-content/themes/lisun/img/default-100x100.jpg'; ?&gt; &lt;div class=&quot;product_details_left_applications_list&quot;&gt; &lt;div class=&quot;product_details_left_applications_list_left&quot;&gt; &lt;img src=&quot;&lt;?php echo $image['sizes']['thumbnail']; ?&gt;&quot;/&gt; &lt;/div&gt; &lt;div class=&quot;product_details_left_applications_list_right&quot;&gt; &lt;a href=&quot;&lt;?php echo get_the_permalink($id); ?&gt;&quot;&gt;&lt;i class=&quot;fas fa-chevron-right&quot;&gt;&lt;/i&gt;&lt;?php echo get_the_title($id); ?&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;?php endforeach; ?&gt; &lt;/div&gt; &lt;?php else: $args = array( 'posts_per_page' =&gt; 5, 'post_type' =&gt; 'applications', 'tax_query' =&gt; array( array( 'taxonomy' =&gt; 'post_tag', 'field' =&gt; 'slug', 'terms' =&gt; $tags, ) ) ); $posts = get_posts( $args );if($posts): ?&gt; &lt;div class=&quot;product_details_left_applications product_details_left_standards&quot;&gt; &lt;div class=&quot;product_details_left_applications_title&quot;&gt;Related Applications&lt;/div&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;?php foreach( $posts as $post ): $image = get_field('application-image',$post-&gt;ID); if(empty($image)) $image['sizes']['thumbnail']='/wp-content/themes/lisun/img/default-100x100.jpg'; ?&gt; &lt;div class=&quot;product_details_left_applications_list&quot;&gt; &lt;div class=&quot;product_details_left_applications_list_left&quot;&gt; &lt;img src=&quot;&lt;?php echo $image['sizes']['thumbnail']; ?&gt;&quot;/&gt; &lt;/div&gt; &lt;div class=&quot;product_details_left_applications_list_right&quot;&gt; &lt;a href=&quot;&lt;?php the_permalink(); ?&gt;&quot;&gt;&lt;i class=&quot;fas fa-chevron-right&quot;&gt;&lt;/i&gt;&lt;?php the_title(); ?&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;?php endforeach; wp_reset_postdata(); ?&gt; &lt;/div&gt;&lt;?php endif; endif; ?&gt; 以上代码需要懂点PHP和Wordpress，有疑问，可以联系我。 ","link":"https://ihopefulchina.github.io/ru-he-yong-tag-fang-shi-chuan-lian-zi-ding-yi-fen-lei-shi-xian-xiang-guan-wen-zhang-chuan-lian-gong-neng/"},{"title":"页面实现类似于淘宝的图窗功能","content":"解决思路: 前台的功能通过JS插件实现。 图片获取通过自定义字段功能获取。 需要用到ACF插件的重复器和Swiper.js &lt;div class=&quot;swiper-container gallery-top&quot;&gt; &lt;div class=&quot;swiper-wrapper&quot;&gt; &lt;?php if( have_rows('product_photo',$post-&gt;ID) ): while ( have_rows('product_photo',$post-&gt;ID) ) : the_row(); $image = get_sub_field('product_photo'); echo '&lt;div class=&quot;swiper-slide&quot;&gt;&lt;img src=&quot;'.$image['sizes']['large'].'&quot; alt=&quot;'.$image['title'].'&quot; /&gt;&lt;/div&gt;'; endwhile; endif; ?&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;gallery-thumb&quot;&gt; &lt;div class=&quot;swiper-container gallery-thumbs&quot;&gt; &lt;div class=&quot;swiper-wrapper&quot;&gt; &lt;?php if( have_rows('product_photo',$post-&gt;ID) ): while ( have_rows('product_photo',$post-&gt;ID) ) : the_row(); $image = get_sub_field('product_photo'); echo '&lt;div class=&quot;swiper-slide&quot;&gt;&lt;img src=&quot;'.$image['sizes']['thumbnail'].'&quot; alt=&quot;'.$image['title'].'&quot; /&gt;&lt;/div&gt;'; endwhile; endif; ?&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;product-button-next&quot;&gt;&lt;i class=&quot;fa fa-angle-right&quot;&gt;&lt;/i&gt;&lt;/div&gt; &lt;div class=&quot;product-button-prev&quot;&gt;&lt;i class=&quot;fa fa-angle-left&quot;&gt;&lt;/i&gt;&lt;/div&gt; &lt;/div&gt; JS部分 //产品详情页产品图 var galleryTop = new Swiper('.gallery-top', { spaceBetween: 10, autoplay: 4000, autoHeight: true, observer: true, observeParents: true, }); var galleryThumbs = new Swiper('.gallery-thumbs', { spaceBetween: 10, centeredSlides: true, slidesPerView: 4, touchRatio: 0.2, slideToClickedSlide: true, autoHeight: true, observer: true, observeParents: true, nextButton: '.product-button-next', prevButton: '.product-button-prev', }); ","link":"https://ihopefulchina.github.io/ye-mian-shi-xian-lei-si-yu-tao-bao-de-tu-chuang-gong-neng/"},{"title":"在非当前页面获取指定多个自定义分类下的文章","content":"在非当前页面，我们获取指定分类就有点困难，ACF插件能解决这个问题，ACF插件是我最常用的插件,用ACF插件定义一个真假按钮，然后判断即可，以下为Demo。 仅供参考（提供一种思路） &lt;?php $args=array( 'order' =&gt; 'ASC', //顺序 'numberposts' =&gt; -1, 'post_type' =&gt; 'products', 'meta_key' =&gt; 'product_btn',// ACF 插件定义一个真假按钮 'meta_value' =&gt; '1',// 1为真，0为假 'posts_per_page'=&gt;-1, ); $arms = array_merge($args, $wp_query-&gt;query); query_posts($arms)?&gt; &lt;?php if (have_posts()) : ?&gt; &lt;?php while (have_posts()) : the_post(); ?&gt; &lt;div class=&quot;swiper-slide&quot;&gt; &lt;?php // 用于图片使用ACF重复器的时候，获取第一张图片 if( have_rows('product_photo',$post-&gt;ID) ): while ( have_rows('product_photo',$post-&gt;ID) ) : the_row(); $image = get_sub_field('product_photo'); echo '&lt;img src=&quot;'.$image['sizes']['medium'].'&quot; alt=&quot;'.$image['title'].'&quot; /&gt;'; break; endwhile; endif; ?&gt; &lt;a class=&quot;product-title&quot; href=&quot;&lt;?php the_permalink(); ?&gt;&quot;&gt;&lt;?php the_title(); ?&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;?php endwhile; ?&gt; &lt;?php endif; wp_reset_query();?&gt; ","link":"https://ihopefulchina.github.io/zai-fei-dang-qian-ye-mian-huo-qu-zhi-ding-duo-ge-zi-ding-yi-fen-lei-xia-de-wen-zhang/"},{"title":"获取指定分类的所有子分类链接、Description、Slug、自定义字段","content":"Wordpress很难获取指定分类下的所有子分类。这需要我们绕路获取。 以下的方法适用于任何页面来获取所有子分类，仅供参考，如果不懂，可以联系我，或者多看几遍官方文档。 分类的标题、Description、Slug是Wordpress自带函数可以直接获取，自定义字段和链接需要通过ID的方式获取。 Demo &lt;?php $test = get_categories(&quot;taxonomy=product&amp;hide_empty=0&quot;); $cats=array(); foreach($test as $tmpcat){ if($tmpcat-&gt;parent==0){ $cats[$tmpcat-&gt;term_id]['name']=$tmpcat-&gt;name; $cats[$tmpcat-&gt;term_id]['slug']=$tmpcat-&gt;slug; $cats[$tmpcat-&gt;term_id]['term_id']=$tmpcat-&gt;term_id; $cats[$tmpcat-&gt;term_id]['description']=$tmpcat-&gt;description; } } ksort($cats); foreach($cats as $key=&gt;$val){ $id = 'term_'.$cats[$key]['term_id']; ?&gt; &lt;div class=&quot;swiper-slide product-content&quot;&gt; &lt;div class=&quot;element-item&quot;&gt; &lt;img src=&quot;&lt;?php echo get_field('products_cate_img', $id); ?&gt;&quot; alt=&quot;&lt;?php echo $cats[$key]['name']; ?&gt;&quot; width=&quot;400&quot; height=&quot;300&quot;&gt; &lt;div class=&quot;content&quot;&gt; &lt;a href=&quot;/products/&lt;?php echo $cats[$key]['slug']; ?&gt;/&quot;&gt;&lt;?php echo $cats[$key]['name']; ?&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;p class=&quot;product-cate-des&quot;&gt;&lt;?php echo $cats[$key]['description']; ?&gt;&lt;/p&gt; &lt;a class=&quot;product-more&quot; href=&quot;/products/&lt;?php echo $cats[$key]['slug']; ?&gt;/&quot;&gt;VIEW MORE&lt;/a&gt; &lt;/div&gt; &lt;?php } ?&gt; ","link":"https://ihopefulchina.github.io/huo-qu-zhi-ding-fen-lei-de-suo-you-zi-fen-lei-lian-jie-descriptionslugzi-ding-yi-zi-duan/"},{"title":"解决Wordpress自定义二级目录和三级目录采用不同的样式","content":"Wordpress自定义分类结构采用的是archive-&gt;taxonomy-&gt;single,其中archive是自定义分类的总页面，taxonomy是子分类，子分类的下面分类，single是自定义分类下的文章。 层级很清晰，但有一个问题，如果二级目录和三级目录采用不同的样式(taxonomy页面)，怎么办？ 其实很好解决这个问题，我们需要理清思路。 采用if语句判断是二级目录还是三级目录，使用$uri=explode('/',$_SERVER['REQUEST_URI']);来切割url，然后判断。 在不同逻辑采用不同样式。 $uri=explode('/',$_SERVER['REQUEST_URI']); &lt;?php if(isset($uri['4'])){?&gt; /*这里输出三级目录的样式 else{ /*这里输出除了三级目录的样式 } 以上只是一种写法，当然，可以写成if..elseif..else,等等来判断。 ","link":"https://ihopefulchina.github.io/jie-jue-wordpress-zi-ding-yi-er-ji-mu-lu-he-san-ji-mu-lu-cai-yong-bu-tong-de-yang-shi/"},{"title":"Wordpress如何添加顶级菜单，和移除、隐藏顶级菜单？","content":"Wordpress后台有很多我们必须要的功能，客户会误点等之类的原因，所以我们需要隐藏一些自定义菜单，但是隐藏顶级菜单，可能下面某一个子菜单是我们需要的。 首先我们先隐藏菜单，这里分为2种隐藏，一种是自带的， 隐藏自带的写这段函数即可 show_admin_bar(false); add_filter('show_admin_bar', '__return_false'); //关闭后台菜单和删除wordpress自带一些功能 //__('Dashboard') ： 控制板菜单 //__('Posts') ： 文章 //__('Media') ： 媒体 //__('Links') ： 链接 //__('Pages') ： 页面 //__('Comments') ： 评论 //__('Appearance') ： 外观 //__('Plugins') ： 插件 //__('Users') ： 用户 //__('Tools') ： 工具 //__('Settings') ： 设置 remove_action('welcome_panel', 'wp_welcome_panel'); function remove_menus() { global $menu; $restricted = array( __('Posts'), __('Links'), __('Comments'), __('Dashboard'), __('Tools'), __('Appearance'), __('Plugins') , // __('Pages'), __('Users'), __('Settings') ); end ($menu); while (prev($menu)){ $value = explode(' ',$menu[key($menu)][0]); if(strpos($value[0], '&lt;') === FALSE) { if(in_array($value[0] != NULL ? $value[0]:&quot;&quot; , $restricted)){ unset($menu[key($menu)]); } }else { $value2 = explode('&lt;', $value[0]); if(in_array($value2[0] != NULL ? $value2[0]:&quot;&quot; , $restricted)){ unset($menu[key($menu)]); } } } } if (is_admin()){ add_action('admin_menu', 'remove_menus'); } function wp_hide_nag() { remove_action( 'admin_notices', 'update_nag', 3 ); } add_action('admin_menu','wp_hide_nag'); 可以选择隐藏哪些菜单，上面有提示，修改即可。 另外一种是隐藏第三方的菜单: function hide_edit_menu() { remove_menu_page('edit.php?post_type=acf-field-group'); } add_action('admin_menu', 'hide_edit_menu', 999); 修改里面的URL'edit.php?post_type=acf-field-group' 即可。 然后是如何添加顶级菜单，这里已添加导航栏菜单为例。 add_action('admin_menu', 'register_custom_menu_page'); function register_custom_menu_page() { add_menu_page('自定义菜单标题', '导航栏菜单', 'administrator', '/nav-menus.php','', 'dashicons-admin-links', 20); } 修改title和URL即可。 ","link":"https://ihopefulchina.github.io/wordpress-ru-he-tian-jia-ding-ji-cai-dan-he-yi-chu-yin-cang-ding-ji-cai-dan/"},{"title":"移除、隐藏、删除Wordpres一些小工具和功能","content":"Wordpress 有些功能不适用定制站(客户可能会乱点到)，所以需要隐藏掉，比如顶部工具栏。 移除顶部工具栏“新建”按钮 function disable_new_content() { global $wp_admin_bar; $wp_admin_bar-&gt;remove_menu('new-content'); } add_action( 'wp_before_admin_bar_render', 'disable_new_content' ); 2.移除顶部工具栏上的评论提示 function remove_comment_bubble() { global $wp_admin_bar; $wp_admin_bar-&gt;remove_menu('comments'); } add_action( 'wp_before_admin_bar_render', 'remove_comment_bubble' ); 3.隐藏显示选项和帮助 function remove_screen_options(){ return false;} add_filter('screen_options_show_screen', 'remove_screen_options'); add_filter( 'contextual_help', 'wpse50723_remove_help', 999, 3 ); function wpse50723_remove_help($old_help, $screen_id, $screen){ $screen-&gt;remove_help_tabs(); return $old_help; } 等等，以上很多功能可以选择加上。 ","link":"https://ihopefulchina.github.io/yi-chu-yin-cang-shan-chu-wordpres-yi-xie-xiao-gong-ju-he-gong-neng/"},{"title":"隐藏、禁止、删除Wordpress自带的更新和仪表盘","content":"Wordpress 更新有点频繁，最恶心的地方是，一旦更新，很多东西都已经没有了，所以最好禁止wordpress更新，仪表盘我个人不喜欢它，所以隐藏，看官们可以选择保留 function example_remove_dashboard_widgets() { // Globalize the metaboxes array, this holds all the widgets for wp-admin global $wp_meta_boxes; unset($wp_meta_boxes['dashboard']['normal']['core']['dashboard_activity']); unset($wp_meta_boxes['dashboard']['normal']['core']['dashboard_right_now']); unset($wp_meta_boxes['dashboard']['normal']['core']['dashboard_recent_comments']); unset($wp_meta_boxes['dashboard']['normal']['core']['dashboard_incoming_links']); unset($wp_meta_boxes['dashboard']['normal']['core']['dashboard_plugins']); unset($wp_meta_boxes['dashboard']['side']['core']['dashboard_primary']); unset($wp_meta_boxes['dashboard']['side']['core']['dashboard_secondary']); unset($wp_meta_boxes['dashboard']['side']['core']['dashboard_quick_press']); unset($wp_meta_boxes['dashboard']['side']['core']['dashboard_recent_drafts']); } add_action('wp_dashboard_setup', 'example_remove_dashboard_widgets' ); function change_footer_admin () {return '';} add_filter('admin_footer_text', 'change_footer_admin', 9999); function change_footer_version() {return '';} add_filter( 'update_footer', 'change_footer_version', 9999); function annointed_admin_bar_remove() { global $wp_admin_bar; /* Remove their stuff */ $wp_admin_bar-&gt;remove_menu('wp-logo'); } add_action('wp_before_admin_bar_render', 'annointed_admin_bar_remove', 0); add_filter('admin_title', 'wpdx_custom_admin_title', 10, 2); function wpdx_custom_admin_title($admin_title, $title){ return $title.' &amp;lsaquo; '.' 这里可以填写title名字'; } add_filter('pre_site_transient_update_core', create_function('$a', &quot;return null;&quot;)); // 关闭核心提示 add_filter('pre_site_transient_update_plugins', create_function('$a', &quot;return null;&quot;)); // 关闭插件提示 add_filter('pre_site_transient_update_themes', create_function('$a', &quot;return null;&quot;)); // 关闭主题提示 add_filter( 'automatic_updater_disabled', '__return_true' );//禁止自动更新 remove_action('admin_init', '_maybe_update_core'); // 禁止检查更新 remove_action('admin_init', '_maybe_update_plugins'); // 禁止更新插件 remove_action('admin_init', '_maybe_update_themes'); // 禁止更新主题 add_filter( 'wpcf7_validate_configuration', '__return_false' ); add_filter( 'post_thumbnail_html', 'remove_width_attribute', 10 ); 用上函数包含隐藏、禁止、删除Wordpress自带的更新和仪表盘，还有修改title名字 ","link":"https://ihopefulchina.github.io/yin-cang-jin-zhi-shan-chu-wordpress-zi-dai-de-geng-xin-he-yi-biao-pan/"},{"title":"禁止删除某些页面","content":"Wordpress的页面，很多是网站构建重要组成部分、网站的基本框架，有部分客户手贱/不小心删除掉页面，导致页面需要重新挂上。 重新挂上，难保客户继续删除掉，所以，需要禁止删除某些页面。 /*禁止删除特定的页面函数*/ function prevent_post_deletion($postid){//保护某些页面不被删除 $protected_post_id = array(101,90,87,307,333,309);//指定页面ID if (in_array($postid,$protected_post_id)) { exit('您要删除的页面为网站基本框架，不能删除，请点击浏览器的后退键进行编辑。'); } } add_action('wp_trash_post', 'prevent_post_deletion'); 注释已详解意思，需要修改的是页面的ID，页面ID获取方法很简单，但后台所在页面的URL就能看到。 ","link":"https://ihopefulchina.github.io/jin-zhi-shan-chu-mou-xie-ye-mian/"},{"title":"如何在导航栏添加图片？","content":"很多客户有在导航栏添加产品图片的需求，Wordpress不支持这一项，需要我们去创建和自定义。 function函数添加这个即可 add_filter('wp_nav_menu_objects', 'my_wp_nav_menu_objects', 10, 2); function my_wp_nav_menu_objects( $items, $args ) { foreach( $items as &amp;$item ) { $img = get_field('nav_product', $item); if( $img ) { $item-&gt;title = '&lt;img src=&quot;'.$img.'&quot;&gt;'.$item-&gt;title; } } return $items; } 其中 $item-&gt;title = '&lt;img src=&quot;'.$img.'&quot;&gt;'.$item-&gt;title;意思是在title添加图片，img来着img 来着img来着img = get_field('nav_product', $item);，这个是ACF插件创建的自定义分类 前台header.php里面的导航栏 不需要修改任何地方，因为已经注入了图片。 if (has_nav_menu('primary')) { wp_nav_menu(array( 'theme_location' =&gt; 'primary', 'menu' =&gt; 'primary', 'depth' =&gt; 0, 'container' =&gt; '', 'container_class' =&gt; '', 'menu_class' =&gt; 'nav navbar-nav', 'items_wrap' =&gt; '&lt;ul class=&quot;%2$s&quot;&gt;%3$s&lt;/ul&gt;' )); } ``` ","link":"https://ihopefulchina.github.io/ru-he-zai-dao-hang-lan-tian-jia-tu-pian/"},{"title":"Wordpress 添加自定义分类","content":"Wordpress 玩法很多，其中自定义分类这一项是很重要的，很多玩法，首先需要学会如何创建自定义分类。 自定义分类这个描述不是很准确，Wordpress 默认只有一个文章，和文章分类，如果我们想创建一个产品类目，案例类目，新闻类目，自带的无法满足这项规定，所以需要自定义分类。 分2种情况，一种不带子分类，如何写？ function products() { $labels = array( 'name' =&gt; _x( '产品', 'post type 名称' ), 'add_new' =&gt; _x( '新建产品', '添加新产品的链接名称' ), 'add_new_item' =&gt; __( '新建一个产品' ), 'edit_item' =&gt; __( '编辑产品' ), 'new_item' =&gt; __( '新产品' ), 'all_items' =&gt; __( '所有产品' ), 'view_item' =&gt; __( '查看产品' ), 'search_items' =&gt; __( '搜索产品' ), 'not_found' =&gt; __( '没有找到产品' ), 'not_found_in_trash' =&gt; __( '回收站里面没有产品' ), 'parent_item_colon' =&gt; '', 'menu_name' =&gt; '产品' ); $args = array( 'labels' =&gt; $labels, 'description' =&gt; '产品', 'public' =&gt; true, 'menu_icon' =&gt; 'dashicons-cart', 'menu_position' =&gt; 13, 'supports' =&gt; array( 'title'), 'has_archive' =&gt; true, ); register_post_type( 'products', $args ); } add_action( 'init', 'products'); 具体参数如何修改和意思，可以参考官方文档 另一种，需要子分类。 在上面的基础上添加 function my_taxonomies_products() { $labels = array( 'name' =&gt; _x( '产品分类', 'taxonomy 名称' ), 'singular_name' =&gt; _x( 'Product', 'taxonomy 单数名称' ), 'search_items' =&gt; __( '搜索产品分类' ), 'all_items' =&gt; __( '所有产品分类' ), 'parent_item' =&gt; __( '该产品分类的上级分类' ), 'parent_item_colon' =&gt; __( '该产品分类的上级分类：' ), 'edit_item' =&gt; __( '编辑产品分类' ), 'update_item' =&gt; __( '更新产品分类' ), 'add_new_item' =&gt; __( '添加新的产品分类' ), 'new_item_name' =&gt; __( '新产品分类' ), 'menu_name' =&gt; __( '产品分类' ), ); $args = array( 'labels' =&gt; $labels, 'hierarchical' =&gt; true, 'rewrite' =&gt; array( 'slug' =&gt; 'products', 'hierarchical' =&gt; true, ) ); register_taxonomy( 'product', 'products', $args ); } add_action( 'init', 'my_taxonomies_products' ); 官方文档有具体修改提示. 其中archive-products.php(产品总分类)，taxonomy-product.php(产品二级分类)，single-products.php（产品详情页） 以上是Wordpress添加自定义分类，道路漫漫，这个是必修课 ","link":"https://ihopefulchina.github.io/wordpress-tian-jia-zi-ding-yi-fen-lei/"},{"title":"页面Url结尾添加斜杠\"/\"","content":"Wordpress 自带不支持 某些页面Url结尾添加斜杠&quot;/&quot;，例如产品总页，Wordpress 输出的地址是 xxx.com/products ,但是符合静态页面Url规则的话，需要在结尾加斜杠， 添加function函数即可。 function nice_trailingslashit($string, $type_of_url) { if ( $type_of_url != 'single' &amp;&amp; $type_of_url != 'page' ) $string = trailingslashit($string); return $string; } add_filter('user_trailingslashit', 'nice_trailingslashit', 10, 2); ","link":"https://ihopefulchina.github.io/ye-mian-url-jie-wei-tian-jia-xie-gang/"},{"title":"修改Wordpress登录后跳转指定页面","content":"Wordpres 后台登录后默认跳转到仪表板，其实是可以修改跳转到指定页面。 在function里面添加一个函数即可。 function my_login_redirect($redirect_to, $request){ if( empty( $redirect_to ) || $redirect_to == 'wp-admin/' || $redirect_to == admin_url() ) return home_url(&quot;/wp-admin/admin.php?page=lanthymessage&quot;); else return $redirect_to; } add_filter(&quot;login_redirect&quot;, &quot;my_login_redirect&quot;, 10, 3); 其中的'/wp-admin/admin.php?page=lanthymessage'是指定的url地址。 以上就是实现Wordpress登录后跳转到指定页面。 ","link":"https://ihopefulchina.github.io/xiu-gai-wordpress-deng-lu-hou-tiao-zhuan-zhi-ding-ye-mian/"},{"title":"PHP动态内容，如何添加Class？","content":"遇到过一个奇怪的需求，客户的邮箱是通过后台填写的，然后前台获取，获取的是一串字符串，例如:xxx@mail.com 但是客户需求是@这个字体要跟别的不一样。。。我只能通过添加class的方法，解决这个需求。 首先 获取动态内容、根据&quot;@&quot;分组字符串。 $email = explode('@',get_field('email', 90)); 然后串联添加输出即可 echo $email[0].'&lt;span class=&quot;email-ico&quot;&gt;@&lt;/span&gt;'.$email[1]; ","link":"https://ihopefulchina.github.io/php-dong-tai-nei-rong-ru-he-tian-jia-class/"},{"title":"Wordpress 面包屑一些问题","content":"Wordpress 本身没有面包屑，但为了SEO我们最好加上这个，用上面包屑，需要解决几个问题。 如何分层次，逐步罗列层级？ 如何获取URL和Title？ 其实很好解决这个问题 在英文网站最好解决。 首先根据url获取当前页面所有slug $uri=explode('/',$_SERVER['REQUEST_URI']); 例如: xxx.com/products/cate/cate-1/xxx.html 打印出来的数组是array(3) { [0]=&gt;&quot;&quot;, [1] =&gt;&quot;products&quot; ,[2]=&gt; &quot;cate&quot;,[3]=&gt; &quot;cate-1&quot;, [4]=&gt; &quot;xxx&quot;,} 然后就可以根据Slug 转换成title &lt;ol class=&quot;breadcrumb&quot;&gt; &lt;li itemscope=&quot;&quot; itemtype=&quot;//data-vocabulary.org/Breadcrumb&quot;&gt;&lt;a href='/' itemprop=&quot;url&quot;&gt;&lt;span itemprop=&quot;title&quot;&gt;&lt;i class=&quot;fas fa-home&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li itemscope=&quot;&quot; itemtype=&quot;//data-vocabulary.org/Breadcrumb&quot;&gt;&lt;a href='/solutions/' itemprop=&quot;url&quot;&gt;&lt;span itemprop=&quot;title&quot;&gt;Solution&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;?php if(isset($uri['4'])):?&gt;&lt;li itemscope=&quot;&quot; itemtype=&quot;//data-vocabulary.org/Breadcrumb&quot;&gt;&lt;a href='/products/&lt;?=$uri[2];?&gt;/' class=&quot;active&quot;&gt;&lt;span itemprop=&quot;title&quot;&gt;&lt;?=str_replace('-',' ',$uri[2]);?&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li itemscope=&quot;&quot; itemtype=&quot;//data-vocabulary.org/Breadcrumb&quot; &gt;&lt;a href='' class=&quot;active&quot;&gt;&lt;span itemprop=&quot;title&quot;&gt;&lt;?=str_replace('-',' ',$uri[3]);?&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;?php elseif(isset($uri['3'])):?&gt; &lt;li itemscope=&quot;&quot; itemtype=&quot;//data-vocabulary.org/Breadcrumb&quot; &gt;&lt;a href='' class=&quot;active&quot;&gt;&lt;span itemprop=&quot;title&quot;&gt;&lt;?=str_replace('-',' ',$uri[2]);?&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;?php endif; ?&gt; &lt;/ol&gt; 以上是英文站的解决方法，那么解决中文站跟slug不匹配的问题？ 很简单，定义一个function函数 function custom_taxonomies_terms_links(){ //根据当前文章ID获取文章信息 $post = get_post( $post-&gt;ID ); //获取当前文章的文章类型 $post_type = $post-&gt;post_type; //获取文章所在的自定义分类法 $taxonomies = get_object_taxonomies( $post_type, 'objects' ); $out = array(); foreach ( $taxonomies as $taxonomy_slug =&gt; $taxonomy ){ $term_list = wp_get_post_terms($post-&gt;ID, $taxonomy_slug, array(&quot;fields&quot; =&gt; &quot;all&quot;)); echo $term_list[0]-&gt;name; //显示文章所处的分类中的第一个 } return implode('', $out ); } 然后获取即可 ","link":"https://ihopefulchina.github.io/wordpress-mian-bao-xie-yi-xie-wen-ti/"},{"title":"解决Wordpress自定义分类archive页面无法通过分类罗列文章的问题","content":"Wordpress有许多奇怪的逻辑，例如我创建一个叫产品的自定义分类，在产品总页面，无法通过自带函数根据产品分类的顺序罗列产品所在分类下的所有产品。 解决思路： 先根据get_categories获取所有产品分类。 根据所有产品分类foreach循环这个分类下的name、slug、term_id。 然后根据这些分类的id(tax_query)获取所有产品。 让我们开始吧。先定义2个数组，其中一个根据get_categories获取所有产品分类。 $test = get_categories(&quot;taxonomy=product&amp;hide_empty=0&quot;); $cats=array(); 然后循环获取name、slug、term_id foreach($test as $tmpcat){ if($tmpcat-&gt;parent==0){ $cats[$tmpcat-&gt;term_id]['name']=$tmpcat-&gt;name; $cats[$tmpcat-&gt;term_id]['slug']=$tmpcat-&gt;slug; $cats[$tmpcat-&gt;term_id]['term_id']=$tmpcat-&gt;term_id; } } 对数组排序 ksort($cats); 最后获取所有产品 &lt;?php $i=0; foreach($cats as $key=&gt;$val){ $id = 'term_'.$cats[$key]['term_id']; $taxId = (int)$cats[$key]['term_id']; $i++; ?&gt; &lt;h2&gt; &lt;a href=&quot;/products/&lt;?php echo $cats[$key]['slug']; ?&gt;/&quot;&gt; &lt;?php echo $cats[$key]['name']; ?&gt; &lt;/a&gt; &lt;/h2&gt; &lt;div class=&quot;clearfix&quot;&gt;&lt;/div&gt; &lt;?php $args=array( 'order' =&gt; 'ASC', 'tax_query' =&gt; array( array( 'taxonomy' =&gt; 'product', 'field' =&gt; 'term_id', 'terms' =&gt; $taxId, ) ) ); $arms = array_merge($args, $wp_query-&gt;query); query_posts($arms); ?&gt; &lt;?php if (have_posts()) : ?&gt; &lt;div class=&quot;all-product&quot;&gt; &lt;?php while (have_posts()) : the_post(); ?&gt; &lt;div class=&quot;col-md-4&quot;&gt; &lt;div class=&quot;re-solution-product&quot;&gt; &lt;div class=&quot;re-solution-product-imgcontent&quot;&gt; &lt;a class=&quot;re-solution-product-img&quot; href=&quot;&lt;?php the_permalink(); ?&gt;&quot;&gt; &lt;img src=&quot;&lt;?php echo get_field('product_img_cate')?&gt;&quot; alt=&quot;&lt;?php the_title()?&gt; images&quot; /&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;re-solution-position&quot;&gt; &lt;div class=&quot;re-solution-content&quot;&gt; &lt;a class=&quot;re-solution-product-title&quot; href=&quot;&lt;?php the_permalink(); ?&gt;&quot;&gt;&lt;?php the_title()?&gt;&lt;/a&gt; &lt;ul&gt; &lt;?php if( have_rows('product_adv') ):while ( have_rows('product_adv') ) : the_row();$adv = get_sub_field('product_adv');echo '&lt;li&gt;'.$adv.'&lt;/li&gt;';endwhile;endif;?&gt; &lt;/ul&gt; &lt;div class=&quot;re-products-content-a-link-s&quot;&gt; &lt;a class=&quot;product-more&quot; href=&quot;&lt;?php the_permalink(); ?&gt;&quot;&gt;More Info &lt;i class=&quot;fas fa-chevron-right&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;?php endwhile; ?&gt; &lt;/div&gt; &lt;div class=&quot;clearfix&quot;&gt;&lt;/div&gt; &lt;?php endif; wp_reset_query();?&gt; &lt;?php } ?&gt; 以上是解决一种思路，如果有什么更好的思路可以一起探讨 Demo: &lt;div class=&quot;taxonomy-products we-all-product&quot;&gt; &lt;?php $test = get_categories(&quot;taxonomy=product&amp;hide_empty=0&quot;); $cats=array(); $cat_child=array(); foreach($test as $tmpcat){ if($tmpcat-&gt;parent==0){ $cats[$tmpcat-&gt;term_id]['name']=$tmpcat-&gt;name; $cats[$tmpcat-&gt;term_id]['slug']=$tmpcat-&gt;slug; $cats[$tmpcat-&gt;term_id]['term_id']=$tmpcat-&gt;term_id; } } ksort($cats); $i=0; foreach($cats as $key=&gt;$val){ $id = 'term_'.$cats[$key]['term_id']; $taxId = (int)$cats[$key]['term_id']; $i++; ?&gt; &lt;h2&gt; &lt;a href=&quot;/products/&lt;?php echo $cats[$key]['slug']; ?&gt;/&quot;&gt; &lt;?php echo $cats[$key]['name']; ?&gt; &lt;/a&gt; &lt;/h2&gt; &lt;div class=&quot;clearfix&quot;&gt;&lt;/div&gt; &lt;?php $args=array( 'order' =&gt; 'ASC', 'tax_query' =&gt; array( array( 'taxonomy' =&gt; 'product', 'field' =&gt; 'term_id', 'terms' =&gt; $taxId, ) ) ); $arms = array_merge($args, $wp_query-&gt;query); query_posts($arms); ?&gt; &lt;?php if (have_posts()) : ?&gt; &lt;div class=&quot;all-product&quot;&gt; &lt;?php while (have_posts()) : the_post(); ?&gt; &lt;div class=&quot;col-md-4&quot;&gt; &lt;div class=&quot;re-solution-product&quot;&gt; &lt;div class=&quot;re-solution-product-imgcontent&quot;&gt; &lt;a class=&quot;re-solution-product-img&quot; href=&quot;&lt;?php the_permalink(); ?&gt;&quot;&gt; &lt;img src=&quot;&lt;?php echo get_field('product_img_cate')?&gt;&quot; alt=&quot;&lt;?php the_title()?&gt; images&quot; /&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;re-solution-position&quot;&gt; &lt;div class=&quot;re-solution-content&quot;&gt; &lt;a class=&quot;re-solution-product-title&quot; href=&quot;&lt;?php the_permalink(); ?&gt;&quot;&gt;&lt;?php the_title()?&gt;&lt;/a&gt; &lt;ul&gt; &lt;?php if( have_rows('product_adv') ):while ( have_rows('product_adv') ) : the_row();$adv = get_sub_field('product_adv');echo '&lt;li&gt;'.$adv.'&lt;/li&gt;';endwhile;endif;?&gt; &lt;/ul&gt; &lt;div class=&quot;re-products-content-a-link-s&quot;&gt; &lt;a class=&quot;product-more&quot; href=&quot;&lt;?php the_permalink(); ?&gt;&quot;&gt;More Info &lt;i class=&quot;fas fa-chevron-right&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;?php endwhile; ?&gt; &lt;/div&gt; &lt;div class=&quot;clearfix&quot;&gt;&lt;/div&gt; &lt;?php endif; wp_reset_query();?&gt; &lt;?php } ?&gt; &lt;/div&gt; ``` ","link":"https://ihopefulchina.github.io/jie-jue-wordpress-zi-ding-yi-fen-lei-archive-ye-mian-wu-fa-tong-guo-fen-lei-luo-lie-wen-zhang-de-wen-ti/"},{"title":"Lnmp on pagespeed","content":"Lnmp-on-pagespeed RedHat, CentOS, or Fedora sudo yum install gcc-c++ pcre-devel zlib-devel make unzip Ubuntu or Debian(一个一个安装，我测试的时候只安装第一个就可以，但发现后面有几次必须安装后面的几个依赖才能100%安装） sudo apt-get install build-essential zlib1g-dev libpcre3 libpcre3-dev unzip apt install uuid-dev apt-get install libssl-dev openssl apt-get install libxslt-dev sudo apt-get install -y libgd-dev apt-get install libgeoip-dev -y LNMP 安装 ngx_pagespeed 的方法 1、首先，根据官方教程下载 Page Speed，把下面的命令保存成 dp.sh 文件，然后运行 chmod +x dp.sh 赋予该文件可执行权限，然后运行 ./dp.sh 即可自动下载并解压 ngx_pagespeed 模块的源代码。 现在最新版本是1.13.35.2-stable。你可以在这里查看最新版本。 制作dp.sh cd nano dp.sh 写入代码,复制粘贴进去，然后Ctrl+X, 输入Y，回车。 #[check the release notes for the latest version] NPS_VERSION=1.13.35.2-stable cd wget https://github.com/apache/incubator-pagespeed-ngx/archive/v${NPS_VERSION}.zip unzip v${NPS_VERSION}.zip nps_dir=$(find . -name &quot;*pagespeed-ngx-${NPS_VERSION}&quot; -type d) cd &quot;$nps_dir&quot; NPS_RELEASE_NUMBER=${NPS_VERSION/beta/} NPS_RELEASE_NUMBER=${NPS_VERSION/stable/} psol_url=https://dl.google.com/dl/page-speed/psol/${NPS_RELEASE_NUMBER}.tar.gz [ -e scripts/format_binary_url.sh ] &amp;&amp; psol_url=$(scripts/format_binary_url.sh PSOL_BINARY_URL) wget ${psol_url} tar -xzvf $(basename ${psol_url}) # extracts to psol/ #[check the release notes for the latest version] NPS_VERSION=1.13.35.2-stablecd cd wget https://github.com/apache/incubator-pagespeed-ngx/archive/v${NPS_VERSION}.zip unzip v${NPS_VERSION}.zip nps_dir=$(find . -name &quot;*pagespeed-ngx-${NPS_VERSION}&quot; -type d)cd &quot;$nps_dir&quot; NPS_RELEASE_NUMBER=${NPS_VERSION/beta/} NPS_RELEASE_NUMBER=${NPS_VERSION/stable/} psol_url=https://dl.google.com/dl/page-speed/psol/${NPS_RELEASE_NUMBER}.tar.gz [ -e scripts/format_binary_url.sh ] &amp;&amp; psol_url=$(scripts/format_binary_url.sh PSOL_BINARY_URL) wget ${psol_url} tar -xzvf $(basename ${psol_url}) # extracts to psol/ 给予权限并运行 chmod +x dp.sh sudo ./dp.sh 从 1.12.34 版本开始，按照官方的教程进行的时候，可能会遇到无法下载 PSOL 的情况，这时候，按照下面的地址下载对应版本的 PSOL 就可以了。 或者使用 https://dl.google.com/dl/page-speed/psol/[PageSpeed版本]-x[系统位数].tar.gz pagespeed下载后修改一下文件夹名字把原来的名字incubator-pagespeed-ngx-1.13.35.2-stable，修改为：ngx_pagespeed-1.13.35.2-stable。 2、然后编辑 Nginx 升级脚本 我用的是 LNMP 1.5，其他版本更换安装路径即可。 配置lnmp文件 cd /root/lnmp1.5/include nano upgrade_nginx.sh 找到 ./configure --user=www --group=www --prefix=/usr/local/nginx，在这行代码的末尾添加，其中 ngx_pagespeed-1.13.35.2-stable 是第一步下载的 PageSpeed 模块的目录名称，根据实际情况替换即可。 加入字段 --add-module=$HOME/ngx_pagespeed-1.13.35.2-stable 接着更新 Nginx，可以根据需要，选择 Nginx 版本升级，一般选择最新的稳定版本即可。我安装的1.14.2. 升级nginx cd ../ sudo ./upgrade.sh nginx 出现错误可以试试 yum install -y libuuid-devel 配置xxx.com.conf 所有的东西安装完毕然后开始配置网站的conf文件： 文件位置在/usr/local/nginx/conf/vhost。 你最好把他下载到桌面编辑。 你可以直接复制我的配置，对应修改一下自己的网站名称： 配置文件写好并上传后，把xxx.com.conf里面内容加进去。 更新缓存 touch /var/cache/ngx_pagespeed/cache.flush ","link":"https://ihopefulchina.github.io/lnmp-on-pagespeed/"},{"title":"解决同一张图片，需要在不同尺寸提供不同的水印","content":"客户需要上传同一张图片，需要在不同尺寸提供不同的水印，我看了、尝试了很多插件，发现基本都不支持多个水印，2个插件组合会出现兼容性问题，只能生效其中一个。 我查阅官方文档，也未找到答案，苦恼如何解决这个问题的时候，找到了Awesome Watermark这个插件，这个是唯一一个支持不同尺寸实现不同水印的要求。 但这个插件有几个问题: 1.siteurl和home的地址必须写域名地址,不能是斜杠。 2.操作很不友好，不适用小白用户。 3.水印大小很固定，只能是Full Size，Large，Medium，Medium Large，Thumbnail。 但瑕不掩瑜，这是唯一一个解决这个问题的插件。 需要注意:最好选择水印图片的时候，什么尺寸的水印，选择什么尺寸大小。 ","link":"https://ihopefulchina.github.io/jie-jue-tong-yi-zhang-tu-pian-xu-yao-zai-bu-tong-chi-cun-ti-gong-bu-tong-de-shui-yin/"},{"title":"关于基于Wordpress的企业网站搭建一些感想","content":"感叹于Wordpress的强大，Wordpress 能让一个网站快速搭建完成，但成也萧何败萧何，做的越久，越发现Wordpress还是把你束缚在Blog里面，本质上Wordprss上还是一个博客系统，强行基于Wordpress搭建网站还是会有些错乱，数据调用和查相关文档，还是要基于博客系统的思维来完成，这是一种扭曲的状态。 丰富的插件，和优秀的贡献开发者，让Wordpress的生态环境在未来很长时间在blog领域有长足的发展，对，仅限于Blog领域，官网和外贸网站的搭建还是欠缺点火候。 历经1年多时间，忙于为各类客户搭建官网和外贸网站，因为公司规模较小，我直接面对客户，在摸索和开发的过程中，发现甲方拥有很多奇思妙想，很多一开始感觉无法通过wordpress系统完成的， 经过摸索、迭代，最终客户大部分功能都可以实现，实现的方式不一样，有的是现成的插件实现，有的需要修改wordpress源码，有的需要通过wordpress的php实现，等等。 基于疲于不同客户很多功能雷同或相似，我迫切需要模块化代码，模块化自定义字段，模块化流程。公司规模较小，没人帮我，我选择自己找和摸索，最终找到了。这样让我的网站编写进程速度大大加快。 模块化的想法付出实施已经有半年了，现在回来有一些对wordpress感想： 1.wordpress能做下去，但国内太小众了，全球有很多网站是基于wordpress搭建的，国外的论坛讨论平台很活跃，国内我找了几个大点的论坛，也死气沉沉的，国内环境太小众，很多时候都是去外网看英文解决问题。 2.臃肿，不适合大型网站，大型企业开发网站，只能偏向于小型企业、外贸网站等等。 3.一次自定义深度开发，不适合长期获取更新wordpress系统。 4.开发速度很快，一般企业网站和外贸网站，一个星期足以完成和交付网站(不包括客户满意度、沟通等等)。 5.上手很快，入门很简单，但想要了解更多，比如搭建企业站，自定义函数等等，就需要很多时间去学习这套系统。 6.本质上这是PHP+Mysql的开发环境，逻辑上跟自己开发基于PHP后台的效果是一样的，就是给套了一个壳。 ","link":"https://ihopefulchina.github.io/guan-yu-ji-yu-wordpress-de-qi-ye-wang-zhan-da-jian-yi-xie-gan-xiang/"},{"title":"Wordpress theme主题结构解析","content":"Wordpress定制站，结构不复杂，了解更多建议去多看看官方文档，下面这个图片是我的定制站需要的文件结构。 需要注意的是product-content.php这个几个文件，是我随便创建的，是因为用到了判断，不同的判断逻辑对应不同的PHP文件，不用在意，index.php和style.css这2个文件必须有，不然挂不上主题。 可能有人注意到了，我这里居然没有function函数，是因为我采用函数模块化的设计，是在后台编写的，这是我必备插件，所以我没有function函数。 ","link":"https://ihopefulchina.github.io/wordpress-theme-zhu-ti-jie-gou-jie-xi/"},{"title":"WordPress函数代码模块化","content":"函数模块化，以简单、简洁、简约的方式添加代码片段到您的站点。再也没有必要去编辑主题的 functions.php 文件。 Github地址：https://github.com/ihopefulChina/Wordpress-function-modular ","link":"https://ihopefulchina.github.io/wordpress-han-shu-dai-ma-mo-kuai-hua/"}]}